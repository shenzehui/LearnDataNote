---
title: MySQL相关面试题汇总
tag: MySQL
category:
  - 面试题
  - MySQL
article: false
---

## ACID 靠什么保证的？

A 原子性，由 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql

C 一致性，有其他三大特征保证、程序代码要保持业务上的一致性

I  隔离性，由 MVCC 来保证

D 持久性，由`内存 + redo log` 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，宕机的时候可以从 redo log 恢复

```sql
InnoDB redo log 写盘,InnoDB 事务进入 prepare 状态。
如果前面 prepare 成功,binlog 写盘,再继续将事务日志持久化到 binlog,如果持久化成功,那么 InnoDB 事务则进入 commit 状态（在 redo log 里面写一个 commit 记录）
```

redolog 的刷盘会在系统空闲时进行

## B 树和 B+ 数的区别，为什么 Mysql 使用 B+ 树？

B 树的特点：

1. 节点排序
2. 一个节点可以存多个元素，多个元素也排序了

B+ 树的特点：

1. 拥有 B 树的特点
2. 叶子节点之间有指针
3. 非叶子节点上的元素在叶子节点都冗余了，也就是叶子节点中存储了所有元素，并且排好顺序

Mysql 索引使用的是 B+ 树，因为索引是用来加快查询的，而 B+ 数通过对数据进行排序所以是可以通过查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得 B+ 树的高度不会太高，在 Mysql 中一个 Innodb 页就是一个 B+ 树节点，一个 Innodb 页默认 16kb，所以一般情况下一颗两层 B+ 树可以存 2000万行左右的数据，然后通过利用 B+ 树叶子节点存储了所有数据并进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等 SQL 语句。

## Mysql 索引结构是怎么样的？聚簇索引和非聚簇索引又是什么？

二叉树 —> AVL 平衡数 —> 红黑树 —> B-树 —> B+ 树

二叉树：每个节点最多只有两个子节点，左边的子节点都比当前节点小，右边的子节点都比当前节点大。

AVL 平衡树：树中任意节点的两个子树的高度差最大为 1

红黑树：

1. 每个节点都是红色或者黑色
2. 根节点是黑色
3. 每个叶子节点都是黑色的空节点。
4. 红色节点的父子节点都必须是褐色。
5. 从任一节点到其每个叶子的所有路径都包含相同的黑色节点

B-树 ：

1. B-树的每个非叶子结点的子节点个数都不会超过 D（这个 D 就是 B-树的阶）
2. 所有的叶子节点都在同一层。
3. 所有节点关键字都是按照递增顺序来排列。

B+树

1. 非叶子节点不存储数据，只进行数据索引。
2. 所有数据都存储在叶子节点当中。
3. 每个叶子节点都存有相邻叶子节点的指针。
4. 叶子节点按照本身关键字从小到大排序。

**聚簇索引就是数据和索引是在一起的，而非聚簇索引就是数据和索引不在一起**

MyISAM 使用的是非聚簇索引，树的子节点上的 data 不是数据本身，而是数据存放的地址。InnoDB 采用的是聚簇索引，树的叶子节点上的 data 就是数据本身。

聚簇索引的数据物理存放顺序和索引顺序是一致的，所以一个表当中只能有一个聚簇索引，而非聚簇索引可以有多个。

InnoDB 中，如果表定义了 PK，那么 PK 就是聚簇索引。如果没有 PK，就会找第一个非空的 unique 列作为聚簇索引。否则，InnoDB 会创建一个 隐藏的 row-id 作为聚簇索引。

Mysql 的覆盖索引和回表

- 如果只需要在一颗索引树上就可以获取 SQL 上所需的所有列，就不需要再回表查询，这样查询速度就可以更快。
- 实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中 。

```sql
user(PK id,name,sex)
select count(name) from user;  —> 在 name 字段上建立一个索引。
select id,name,sex from user;  —> 将 name 上的索引升级成为 (name,sex)的联合索引
```

## Innodb 是如何实现事务的？

Innodb 通过 Buffer Pool，LogBuffer，Redo Log，Undo Log 来实现事务，以一个 upload 语句为例：

1. Innodb 在收到一个 update 语句后，会先根据条件找到数据所在页，并将该页缓存在 Buffer Pool 中
1. 执行 update 语句，修改 Buffer Pool 中的数据，也就是内存中的数据
1. 针对 update 语句生成一个 RedoLog 对象，并存入 LogBuffer 中
1. 针对 update 语句生成 undoLog 日志，用于事务回滚
1. 如果事务提交，那么则把 RedoLog 对象进行持久化，后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中
1. 如果事务回滚，则利用 undoLog 日志进行回滚

## Mysql 索引的数据结构，各自优劣

索引的数据结构和具体索引引擎的实现相关，在 Mysql 中使用较多的索引有 Hash 索引，B+树索引等，**InnoDB 存储引擎的默认索引实现为：B+树索引。**对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单表记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择B树索引

**B+树索引：**

B+树是一个平衡多叉树，从根节点到每个叶子节点的高度值不超过1，而且同层级的节点间有指针互相链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。

![](https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/9ae2d6fb0ec7b2fb87a7c428e266acad.png)

**哈希索引：**

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到了叶子节点逐级查找，只需要一次哈希算法即可立即定位到响应的位置，速度非常快

![](https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/2352266-20210710151708167-1675912757.png)

- keys：代表创建索引的列值；

- buckets： 就是计算出来的hash值和对应的数据的物理位置组成的hash表；

- entries：就是代表具体的数据行；

创建hash索引后，会为每个键值通过特定的算法计算出一个哈希码（hash code)，需要注意的是不同的键值计算出来的hash值可能是相同的，例上图上的 John Smith 和Sandra Dee算出来的hash值都是152，然后找到hash值为152在hash表中的存储数据的物理位置，这个位置对应着两条数据也(就是John Smith 521-1234 和Sandra Dee 521-9655)，然后再次遍历这两条数据，找到需要的数据，这就解释了为啥hash冲突严重了。

如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提是键值都是唯一的。如果键值不是唯一的，就需要找到该键所在位置，然后再根据链表往后扫描，直到找到响应的数据。

如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能不连续了，就没办法再利用索引完成范围查询检索。

哈希索引也没办法利用索引完成排序，以及 like 'xxx%' 这样的部分模糊查询（这种部分模糊查询，其实本质也是范围查询）；

哈希索引也不支持多级联合索引的最左匹配规则；

B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。

## Mysql 的集群如何搭建的？读写分离是怎么做的？

Mysql 主从集群的搭建原理：

1. master 将操作语句记录到 binlog （记录的是每一步的数据操作）日志中

2. salve 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变

3. salve 开启两个线程：IO 线程和 SQL 线程

   - IO 线程：负责读取 master 的 binlog 内容到中继日志 relay log 里

   
   - SQL 线程：负责从 relay log 日志里读出 binlog 内容，并更新到 slave 的数据库里（保证数据一致）

![](https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/1080958-20190716114159060-648770948.png)

MySQL 通过将主节点的 Binlog 同步给节点完成主从之间的数据同步。

MySQL 的主从集群只会将 binlog 从主节点到从节点，而不会反过来同步。由此也就引申出了读写分离的问题。

**因为要保证主从之间的数据一致，写数据的操作只能在主节点完成。而读数据的操作，可以在主节点或者从节点上完成。**

## Mysql 执行计划怎么看？

**执行计划就是 sql 的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数**

EXPLAIN SELECT * from  A where X=? and Y=?

![image-20221112123752976](https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/image-20221112123752976.png)

1. id：是一个有顺序的编号，是查询的顺序号，有几个 select 就是显示几行，id 的顺序是按 select 出现的顺序增长的。id 列的值越大执行优先级越高越先执行，id 列的值相同则从上往下执行，id 列的值为 NULL 最后执行。
2. selectType 表示查询中每个 select 子句的类型
   - SIMPLE：表示此查询不包含 UNION 查询或子查询
   - PRIMARY：表示此查询的最外层的查询（包含子查询）
   - SUBQUERY：子查询中的第一个 SELECT
   - UNION：表示此查询是 UNION 的第二或随后的查询
   - DEPENENT UNION：UNION 中的第二个或后面的查询语句，取决于外面的查询
   - UNION RESULT，UNION 的结果
   - DEPENDENT SUBQUERY：子查询的第一个 SELECT，取决于外面的查询，即子查询依赖于外层查询的结果
   - DERIVER：衍生，表示导出表的 SELECT（FROM 子句的子查询）
3. table：表示该语句查询的表
4. **type：**优化 sql 的重要字段，也是我们判断 sql 性能的优化程度重要指标，他的取值类型范围：
   - const：通过索引一次命中，匹配一行数据
   - system：表中只有一行数据，相当于系统表（效率优于 const）
   - eq_ref：唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配
   - ref：非唯一性索引扫描，返回匹配某个值的所有
   - range：只检索给定范围的行，使用一个索引来选择行，一般用 between、<、>；
   - index：只遍历索引树；
   - ALL：表示全表扫描，这个类型的查询是性能最差的查询之一。那么基本就是随着表的数量增多，执行效率越慢。（没有走索引）

**执行效率：**

**ALL < index < range < ref < eq_ref < const < system。最好是避免 ALL 和 index**

5. possible_keys：它表示 Mysql 在执行该 sql 语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。
6. key：此字段是 mysql 在当前查询时所真正使用到的索引，它是 possible_keys 的子集
7. key_len：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是我们优化 sql 时，评估索引的重要指标。
8. rows：mysql 查询优化器根据统计信息，估算该 sql 返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大
9. filtered：返回结果的行占需要读取的行（rows 列的值）的百分比，就是百分比越高，说明需要查询到数据越准确，百分比越小，说明查询到的数据量大，而结果集很少
10. extra
    - using filesort：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果，一般有 using filesort 都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。
    - using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。
    - using temporary：查询有使用临时表，一般出现于排序，分组和多表 join 的情况，查询效率不高，建议优化。
    - using where：sql 使用了 where 过滤，效率较高

## Mysql 主从同步原理

Mysql 主从同步的过程：

Mysql 的主从复制中主要有三个线程：`master（binlog dump thread）、slave（I/O thread、SQL thread）`，Master 一条线程和 Slave 中的两条线程。

- 主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务器启动那一刻起，保存所有修改数据库结构或内容的一个文件。
- 主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。
- 从节点 I/O 线程接收 binlog 内容，并将其先入 relay log（中继日志） 文件中。
- 从节点的 SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。

注：主从节点使用 binlog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。

由于 mysql 默认的复制方式是异步的，主库把日志发送给从库后不关系从库是否已经处理，这样产生一个问题就是假设主库挂了，从库处理失败，这时候从库升为主库后，日志就丢失了。由此产生两个概念：

**全同步复制**

主库写入 binlog 后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。

**半同步复制**

和全同步不同的是，半同步赋值的逻辑是这样的，从库写入日志成功后返回 ACK 确认给主库，主库收到至少一个从库的确认就认为写操作完成。

## Mysql 有哪几种数据存储引擎？有什么区别？

MySQL 通过 show ENGINES 指令可以看到所有支持的数据库存储引擎。

```sql
show ENGINES
```

![](https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/image-20221112132846604.png)

其中最为常用的是 `MyISAM` 和 `InnoDB`

MyISAM 和 InnoDB 的区别：

1. 存储文件。MyISAM 每个表有两个文件，MYD 和 MYISAM 文件。其中，MYD 是数据文件，MyISAM 是索引文件。而 InnoDB 每个表只有一个文件：ibd。
2. InnoDB 支持事务，支持行级锁，支持外键。
3. InnoDB 支持 XA 事务
4. InnoDB 支持 Savepoints：部分回滚

```sql
XA START 'test';
INSERT ....
XA END 'test';
XA PREPARE 'test';
XA COMMIT 'test'
XA ROLLBACK 'test';
```

## 简述 Mysql 中索引类型及对数据库的性能的影响

普通索引：允许被索引的数据列包含重复的值。

唯一索引：可以保证数据记录的唯一性。

主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。

联合索引：索引可以覆盖多个数据列，如像 INDEX（colunmA，columnB）索引。

全文索引：通过建立 `倒排索引`，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术，可以通过 ALTER TABLE table_name ADD FULLTEXT（column）创建全文索引

索引可以极大的提高数据的查询速度

通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

但是会降低插入、删除、更新表的速度，因为在执行这些操作时，还要操作索引文件

索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果需要建立聚簇索引，那么需要的空间就会更大，如果非聚簇索引很多，一旦聚簇索引改变，那么所有非聚簇索引都会跟着变
