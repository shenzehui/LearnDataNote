---
title: Mysql 精选面试题🔥
tag: Mysql
category:
  - 面试题
  - 数据库
article: false
---

## ACID 靠什么保证的？

A 原子性，由 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql

C 一致性，有其他三大特征保证、程序代码要保持业务上的一致性

I  隔离性，由 MVCC 来保证

D 持久性，由`内存 + redo log` 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，宕机的时候可以从 redo log 恢复

```sql
InnoDB redo log 写盘,InnoDB 事务进入 prepare 状态。
如果前面 prepare 成功,binlog 写盘,再继续将事务日志持久化到 binlog,如果持久化成功,那么 InnoDB 事务则进入 commit 状态(在 redo log 里面写一个 commit 记录)
```

redolog 的刷盘会在系统空闲时进行

## B 树和 B+ 数的区别，为什么 Mysql 使用 B+ 树？

B 树的特点：

1. 节点排序
2. 一个节点可以存多个元素，多个元素也排序了

B+ 树的特点：

1. 拥有 B 树的特点
2. 叶子节点之间有指针
3. 非叶子节点上的元素在叶子节点都冗余了，也就是叶子节点中存储了所有元素，并且排好顺序

Mysql 索引使用的是 B+ 树，因为索引是用来加快查询的，而 B+ 数通过对数据进行排序所以是可以通过查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得 B+ 树的高度不会太高，在 Mysql 中一个 Innodb 页就是一个 B+ 树节点，一个 Innodb 页默认 16kb，所以一般情况下一颗两层 B+ 树可以存 2000万行左右的数据，然后通过利用 B+ 树叶子节点存储了所有数据并进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等 SQL 语句。

## Mysql 索引结构是怎么样的？聚簇索引和非聚簇索引又是什么？

二叉树 —> AVL 平衡数 —> 红黑树 —> B-树 —> B+ 树

二叉树：每个节点最多只有两个子节点，左边的子节点都比当前节点小，右边的子节点都比当前节点大。

AVL 平衡树：树中任意节点的两个子树的高度差最大为 1

红黑树：

1. 每个节点都是红色或者黑色
2. 根节点是黑色
3. 每个叶子节点都是黑色的空节点。
4. 红色节点的父子节点都必须是褐色。
5. 从任一节点到其每个叶子的所有路径都包含相同的黑色节点

B-树 ：

1. B-树的每个非叶子结点的子节点个数都不会超过 D(这个 D 就是 B-树的阶)
2. 所有的叶子节点都在同一层。
3. 所有节点关键字都是按照递增顺序来排列。

B+树

1. 非叶子节点不存储数据，只进行数据索引。
2. 所有数据都存储在叶子节点当中。
3. 每个叶子节点都存有相邻叶子节点的指针。
4. 叶子节点按照本身关键字从小到大排序。

**聚簇索引就是数据和索引是在一起的，而非聚簇索引就是数据和索引不在一起**

MyISAM 使用的是非聚簇索引，树的子节点上的 data 不是数据本身，而是数据存放的地址。InnoDB 采用的是聚簇索引，树的叶子节点上的 data 就是数据本身。

聚簇索引的数据物理存放顺序和索引顺序是一致的，所以一个表当中只能有一个聚簇索引，而非聚簇索引可以有多个。

InnoDB 中，如果表定义了 PK，那么 PK 就是聚簇索引。如果没有 PK，就会找第一个非空的 unique 列作为聚簇索引。否则，InnoDB 会创建一个 隐藏的 row-id 作为聚簇索引。

Mysql 的覆盖索引和回表

- 如果只需要在一颗索引树上就可以获取 SQL 上所需的所有列，就不需要再回表查询，这样查询速度就可以更快。
- 实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中 。

```sql
user(PK id,name,sex)
select count(name) from user;  —> 在 name 字段上建立一个索引。
select id,name,sex from user;  —> 将 name 上的索引升级成为 (name,sex)的联合索引
```

## Innodb 是如何实现事务的？

Innodb 通过 Buffer Pool，LogBuffer，Redo Log，Undo Log 来实现事务，以一个 upload 语句为例：

1. Innodb 在收到一个 update 语句后，会先根据条件找到数据所在页，并将该页缓存在 Buffer Pool 中
1. 执行 update 语句，修改 Buffer Pool 中的数据，也就是内存中的数据
1. 针对 update 语句生成一个 RedoLog 对象，并存入 LogBuffer 中
1. 针对 update 语句生成 undoLog 日志，用于事务回滚
1. 如果事务提交，那么则把 RedoLog 对象进行持久化，后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中
1. 如果事务回滚，则利用 undoLog 日志进行回滚

## Mysql 索引的数据结构，各自优劣

索引的数据结构和具体索引引擎的实现相关，在 Mysql 中使用较多的索引有 Hash 索引，B+树索引等，**InnoDB 存储引擎的默认索引实现为：B+树索引。**对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单表记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择B树索引

**B+树索引：**

B+树是一个平衡多叉树，从根节点到每个叶子节点的高度值不超过1，而且同层级的节点间有指针互相链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。

![](https://s1.vika.cn/space/2022/11/21/6bb686de34bd4aa9b05222a8af9a4461)

**哈希索引：**

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到了叶子节点逐级查找，只需要一次哈希算法即可立即定位到响应的位置，速度非常快

![](https://s1.vika.cn/space/2022/11/21/60ef681f077441c89cb6dc434ed91fd2)

- keys：代表创建索引的列值；

- buckets： 就是计算出来的hash值和对应的数据的物理位置组成的hash表；

- entries：就是代表具体的数据行；

创建hash索引后，会为每个键值通过特定的算法计算出一个哈希码(hash code)，需要注意的是不同的键值计算出来的hash值可能是相同的，例上图上的 John Smith 和 Sandra Dee 算出来的hash值都是152，然后找到 hash 值为152在hash表中的存储数据的物理位置，这个位置对应着两条数据也(就是 John Smith 521-1234 和 Sandra Dee 521-9655)，然后再次遍历这两条数据，找到需要的数据，这就解释了为啥 hash 冲突严重了。

如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提是键值都是唯一的。如果键值不是唯一的，就需要找到该键所在位置，然后再根据链表往后扫描，直到找到响应的数据。

如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能不连续了，就没办法再利用索引完成范围查询检索。

哈希索引也没办法利用索引完成排序，以及 like 'xxx%' 这样的部分模糊查询(这种部分模糊查询，其实本质也是范围查询)；

哈希索引也不支持多级联合索引的最左匹配规则；

B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。

## Mysql 的集群如何搭建的？读写分离是怎么做的？

Mysql 主从集群的搭建原理：

1. master 将操作语句记录到 binlog (记录的是每一步的数据操作)日志中

2. salve 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变

3. salve 开启两个线程：IO 线程和 SQL 线程

   - IO 线程：负责读取 master 的 binlog 内容到中继日志 relay log 里

   
   - SQL 线程：负责从 relay log 日志里读出 binlog 内容，并更新到 slave 的数据库里(保证数据一致)

![](https://s1.vika.cn/space/2022/11/21/d2467e62fdd54cc195ce74dace2f60de)

MySQL 通过将主节点的 Binlog 同步给节点完成主从之间的数据同步。

MySQL 的主从集群只会将 binlog 从主节点到从节点，而不会反过来同步。由此也就引申出了读写分离的问题。

**因为要保证主从之间的数据一致，写数据的操作只能在主节点完成。而读数据的操作，可以在主节点或者从节点上完成。**

## Mysql 执行计划怎么看？

**执行计划就是 sql 的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数**

EXPLAIN SELECT * from  A where X=? and Y=?

![image-20221112123752976](https://s1.vika.cn/space/2022/11/21/d0b8ac6923f24e6a92ed2308ee978c67)

1. id：是一个有顺序的编号，是查询的顺序号，有几个 select 就是显示几行，id 的顺序是按 select 出现的顺序增长的。id 列的值越大执行优先级越高越先执行，id 列的值相同则从上往下执行，id 列的值为 NULL 最后执行。
2. selectType 表示查询中每个 select 子句的类型
   - SIMPLE：表示此查询不包含 UNION 查询或子查询
   - PRIMARY：表示此查询的最外层的查询(包含子查询)
   - SUBQUERY：子查询中的第一个 SELECT
   - UNION：表示此查询是 UNION 的第二或随后的查询
   - DEPENENT UNION：UNION 中的第二个或后面的查询语句，取决于外面的查询
   - UNION RESULT，UNION 的结果
   - DEPENDENT SUBQUERY：子查询的第一个 SELECT，取决于外面的查询，即子查询依赖于外层查询的结果
   - DERIVER：衍生，表示导出表的 SELECT(FROM 子句的子查询)
3. table：表示该语句查询的表
4. **type：**优化 sql 的重要字段，也是我们判断 sql 性能的优化程度重要指标，他的取值类型范围：
   - const：通过索引一次命中，匹配一行数据
   - system：表中只有一行数据，相当于系统表(效率优于 const)
   - eq_ref：唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配
   - ref：非唯一性索引扫描，返回匹配某个值的所有
   - range：只检索给定范围的行，使用一个索引来选择行，一般用 between、<、>；
   - index：只遍历索引树；
   - ALL：表示全表扫描，这个类型的查询是性能最差的查询之一。那么基本就是随着表的数量增多，执行效率越慢。(没有走索引)

**执行效率：**

**ALL < index < range < ref < eq_ref < const < system。最好是避免 ALL 和 index**

5. possible_keys：它表示 Mysql 在执行该 sql 语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。
6. key：此字段是 mysql 在当前查询时所真正使用到的索引，它是 possible_keys 的子集
7. key_len：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是我们优化 sql 时，评估索引的重要指标。
8. rows：mysql 查询优化器根据统计信息，估算该 sql 返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大
9. filtered：返回结果的行占需要读取的行(rows 列的值)的百分比，就是百分比越高，说明需要查询到数据越准确，百分比越小，说明查询到的数据量大，而结果集很少
10. extra
    - using filesort：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果，一般有 using filesort 都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。
    - using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。
    - using temporary：查询有使用临时表，一般出现于排序，分组和多表 join 的情况，查询效率不高，建议优化。
    - using where：sql 使用了 where 过滤，效率较高

## Mysql 主从同步原理

Mysql 主从同步的过程：

Mysql 的主从复制中主要有三个线程：`master(binlog dump thread)、slave(I/O thread、SQL thread)`，Master 一条线程和 Slave 中的两条线程。

- 主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务器启动那一刻起，保存所有修改数据库结构或内容的一个文件。
- 主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。
- 从节点 I/O 线程接收 binlog 内容，并将其先入 relay log(中继日志) 文件中。
- 从节点的 SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。

注：主从节点使用 binlog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。

由于 mysql 默认的复制方式是异步的，主库把日志发送给从库后不关系从库是否已经处理，这样产生一个问题就是假设主库挂了，从库处理失败，这时候从库升为主库后，日志就丢失了。由此产生两个概念：

**全同步复制**

主库写入 binlog 后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。

**半同步复制**

和全同步不同的是，半同步赋值的逻辑是这样的，从库写入日志成功后返回 ACK 确认给主库，主库收到至少一个从库的确认就认为写操作完成。

## Mysql 有哪几种数据存储引擎？有什么区别？

MySQL 通过 show ENGINES 指令可以看到所有支持的数据库存储引擎。

```sql
show ENGINES
```

![](https://s1.vika.cn/space/2022/11/21/9ce1d66f2cf74fb7b71687b6a321a060)

其中最为常用的是 `MyISAM` 和 `InnoDB`

MyISAM 和 InnoDB 的区别：

1. 存储文件。MyISAM 每个表有两个文件，MYD 和 MYISAM 文件。其中，MYD 是数据文件，MyISAM 是索引文件。而 InnoDB 每个表只有一个文件：ibd。
2. InnoDB 支持事务，支持行级锁，支持外键。
3. InnoDB 支持 XA 事务
4. InnoDB 支持 Savepoints：部分回滚

```sql
XA START 'test';
INSERT ....
XA END 'test';
XA PREPARE 'test';
XA COMMIT 'test'
XA ROLLBACK 'test';
```

## 简述 Mysql 中索引类型及对数据库的性能的影响

普通索引：允许被索引的数据列包含重复的值。

唯一索引：可以保证数据记录的唯一性。

主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。

联合索引：索引可以覆盖多个数据列，如像 INDEX(colunmA，columnB)索引。

全文索引：通过建立 `倒排索引`，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术，可以通过 ALTER TABLE table_name ADD FULLTEXT(column)创建全文索引

索引可以极大的提高数据的查询速度

通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

但是会降低插入、删除、更新表的速度，因为在执行这些操作时，还要操作索引文件

索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果需要建立聚簇索引，那么需要的空间就会更大，如果非聚簇索引很多，一旦聚簇索引改变，那么所有非聚簇索引都会跟着变。

## 能说下 myisam 和 innodb 的区别吗？

myisam 引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于大量查询少量插入的场景来使用，而且 myisam 不支持外键，并且索引和数据是分开存储的。

innodb 是基于 B+Tree 索引来建立的，和 myisam 相反，它支持事务、外键，并且通过 MVCC(多版本并发控制) 来支持高并发，索引和存储数据是一起的。

## 说下 MySQL 索引有哪些吧？

索引在什么层面？

首先，索引是在**存储引擎层实现**的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现

有哪些？

- **B+Tree 索引**

是大多数 MySQL 存储引擎的默认索引类型。

- **哈希索引**
  - 哈希索引能以 O(1) 时间进行查找，但是失去了有序性；
  - innoDB 存储引擎有一个特殊功能叫"自适应哈希索引"，当某个索引值被使用的非常频繁，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
- **全文索引**
  - MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。
  - 全文索引一般使用倒排索引实现，它记录者关键词到其所在的文档的映射
  - InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。
- **空间数据索引**
  - MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度进行组合查询。

## 什么是B+树？为什么B+树成为主要的SQL数据库的索引实现？

- **什么是 B+Tree?**

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi + 1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于 keyi+1。

![img](https://s1.vika.cn/space/2022/11/21/0db487dddbc141269cc266f6a0745933)

- **为什么是 B+ Tree？**
  - 为了减少磁盘读取次数，决定了树的高度不能高，所以必须是先 B-Tree；
  - 以页为单位读取使得一次 I/O 就能完全载入一个节点，且相邻的节点也能够被预先载入；所以数据放在叶子节点，本质上是一个 Page 页；
  - 为了支持范围查询以及关联关系，页中数据需要有序，且页的尾部节点指向下一个页的头部；
- **B+ 树索引可以分为聚簇索引和非聚簇索引？**

1. 主索引就是聚簇索引(也称为聚集索引，clustered index)
2. 辅助索引(有时也称非聚簇索引或二级索引，secondary index，non-clustered index)。

![img](https://s1.vika.cn/space/2022/11/21/8b1cbc2f2c814db8846a1cc0bc4021e3)

如上图，**主键索引的叶子节点保存的是真正的数据。而辅助索引叶子节点的数据区保存的是主键索引关键字的值**

假设要查询 name == C 的数据，其搜索过程如下：

​	a)先在辅助索引中通过 C 查询最后找到主键 id = 9；

​	b)在主键索引中搜索 id 为9的数据，最终在主键索引的叶子节点中获取到真正的数据。所以 通过辅助索引进行检索，需要检索两次索引。

之所以这样设计，一个原因就是：如果和 MyISAM 一样在主键索引和辅助索引的叶子节点中都存放数据行指针，一旦数据发生迁移，则需要去重新组织维护所有的索引。

## 那你知道什么是覆盖索引和回表吗？

覆盖索引指是在一次查询中，如果**一个索引包含或者说覆盖所有需要查询的字段的值**，我们就称之为覆盖索引，而不再需要回表查询。

而要确定一个查询是否是覆盖索引，我们只需要 explain sql 语句看 Extra 的结果是否是"Using index"即可。

比如：

```sql
explain select * from user where age=1; // 查询的name无法从索引数据获取
explain select id,age from user where age=1; //可以直接从索引获取
```

## 什么是 MVCC？ 说说 MySQL 实现 MVCC 的原理？

- **什么是 MVCC？**

MVCC，全称 Multi-Version Concurrency Control，即`多版本并发控制`。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

在 Mysql 的 InnoDB 引擎中就是指在`已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)`这两种隔离级别下的事务对于 SELECT 操作会访问版本链中的记录的过程。

这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。

- **MySQL 的 InnoDB 引擎实现 MVCC 的3个基础点**

1. **隐式字段**

![img](https://s1.vika.cn/space/2022/11/21/71cf6ec8cd494a6ab9c54fc58446bf4c)

如上图，DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键；DB_TRX_ID 是当前操作该记录的事务 ID；而 DB_ROLE_PTR 是一个回滚指针，用于配合 undo 日志，指向上一个旧指针；delete flag 没有展示出来。

2. **undo log**

![img](https://s1.vika.cn/space/2022/11/21/0b569fd897324ce7a70d390aae11e1d5)

从上面，我们就可以看出，不同事务或者相同事务的同一记录的修改，会导致该记录的 undo log 成为一条记录版本线性表，即链表，undo log 的链首就是最新的旧记录，链尾就是最早的旧记录

3. **ReadView**

已提交读和可重复读的区别就在于它们生成 ReadView 的策略不同。

ReadView 中主要有两个列表来存储我们系统中当期那活跃着的读写事务，也就是 begin 了还未提交的事务。通过这个列表来判断记录的某个版本是否对当期事务可见。假设当前列表里的事务 id 为[80,100].

 	a) 如果你要访问的记录版本的事务 id 为 50，比当前列表最小的 id 80 小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。
 	
 	b) 如果你要访问的记录版本的事务 id 为 90，发现此事务在列表 id 最大值和最小值之间，那就判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能访问，如果不在那说明事务已经提交，所以此版本可以被访问。

​	c) 如果你要访问的记录版本的事务 id 为110，那比事务列表最大 id 100 都大，那说明这个版本是在 ReadView 生成之后才发生的，所以不能被访问。

这些记录都是去 undo log 链里面找的，先找最近记录，如果最近这一条记录事务 id 不符合条件，不可见的话，再去找上一个版本比较当前事务的 id 和这个版本事务 id 能不能访问，以此类推直到返回可见的版本或者结束。

- **举个例子** ，在已提交读隔离级别下

比如此时有一个事务 id 为100的事务，修改了 name，使得 name 等于小明2，但是事务还没提交，则此时的版本链是

![img](https://s1.vika.cn/space/2022/11/21/a59d3f8720ff42c98f3222056d18c267)

那此时另一个事务发起了 select 语句要查询 id 为1的记录，那此时生成的 ReadView 列表只有[100]。那就去版本链找，首先肯定先找最近的一条，发现 trx_id 是100，也就是 name 为小明2的那条记录，发现在列表内，所以不能访问。

这时候就通过指针继续找下一条，name 为小明1的记录，发现 trx_id 是60，小于 列表中的最小 id，所以可以访问，访问结果为小明1.

那这个时候我们把事务 id 为100的事务提交了，并且新建一个事务 id 为110也修改 id 为1的记录，并且不提交事务

![img](https://s1.vika.cn/space/2022/11/21/aa0c7fd158044988b8c31eb663920369)

这时候版本链就是

![img](https://s1.vika.cn/space/2022/11/21/2913a7b1170140099af6cd6aa150fa98)

这时候之前那个 select 事务又执行了一次查询，要查询  id 为1的记录。

**已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的 ReadView，而可重复读隔离级别则在第一次读的时候生成一个 ReadView，之后的读都复用之前的 ReadView**。

1. 如果你是已提交读隔离级别，这时候你会重新生成一个 ReadView，那你的活动事务列表中的值就变了，完成了[110]。按照以上的说法，你去版本链通过 trx_id 对比查找合适的结果就是小明2.

2. 如果你是可重复读隔离级别，这时候你的 ReadView 还是第一次 select 时候生成的 ReadView，也就是列表的值还是[100]。所以 select 的结果是小明1。所以第二次 select 结果和第一次一样，所以叫可重复读！

这就是 Mysql 的 MVVC，通过版本链，实现多版本，可并发读-写，写-读。通过 ReadView 生成策略的不同实现不同的隔离级别。

## MySQL 锁的类型有哪些呢？🚩

**说两个维度**：

- 共享锁（简称 S 锁）和排他锁（简称 X 锁）
  - **读锁**是共享的，可以通过 lock in share mode 实现，这时候只能读不能写。
  - **写锁**是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁两种。
- 表锁和行锁
  - **表锁**会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如 alter 修改表结构的时候去锁表。
  - **行锁**又可以分为乐观锁和悲观锁
    - 悲观锁可以通过 for update 实现
    - 乐观锁可以通过版本号实现

**两个维度结合来看：**

- 共享锁(行锁)：Shared Locks
  - 读锁（s 锁），多个事务对于同一个数据可以共享访问，不能操作修改
  - 使用方法 ：
    - 加锁：select * FROM table WHERE id = 1 LOCK IN SHARE MODE
    - 释放：COMMIT/ROLLBACK
- 排他锁（行锁）：Exclulsive Locks
  - 写锁（X 锁），互斥锁/独占锁，事务获取一个数据 X 锁，其他事务就不能获取该行的读锁和写锁（s锁、X 锁），只有获取了该排他锁的事务是可以对数据行进行读取和修改
  - 使用方法：
    - DELETE/UPDATE/INSERT --加锁
    - SELECT * FROM table WHERE ... FOR UPDATE --加锁
    - COMMIT/ROLLBACK --释放锁
- 意向共享锁（IS）
  - 一个数据行加共享锁前必须先取得该表的 IS 锁，意向共享锁之间是可以相互兼容的；意向排他锁（IX）一个数据加排他锁前必须先取得该表的 IX 锁，意向排他锁之间是可以互相兼容的；意向锁（IS、IX）是 InnoDB 引擎操作数据之前自动加的，不需要用户干预；意义：当事务操作需要锁表时，只需判断意向锁是会否存在，存在时则可快速返回表不能启用表锁
  - 意向共享锁（IS 锁）（表锁）：Intention Shared Locks
    - 表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的 IS 锁。
  - 意向排他锁（IX 锁）（表锁）：Intention Exclusive Locks
    - 表示事务准备给数据加入排它锁，说明事务在一个数据行加排在他锁前必须先获取该表的 IX 锁。

## 你们数据量级多大？分库分表怎么做的？🚀

首先分库分表分为垂直和水平两个方式，一般来说我们拆分的顺序是先垂直后水平。

- **垂直分库**



- **垂直分表**

## 什么是内连接、外连接、交叉连接、笛卡尔积呢？

- 内连接（inner join）：取得两张表中满足存在连接匹配关系的记录，内连接相当于左右拼表。

内连接语法结构：

```sql
select 查询字段 from 表1[inner] join 表2 on 表1.关系字段 = 表2.关系字段;（等值连接）
```

也可以写成如下的形式，连接条件写在where子句中：

```sql
select 查询字段 from 表1,表2 where 表1.关系字段=表2.关系字段;
```

- 外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。（一般查询出来的数据会存在空字段）
  - **左外连接：select..from 表1 left join 表2 on 条件(表1:为左表，表2：为右表)**
  - **右外连接：select..from表1 reght join 表2 on 条件(表1:为左表，表2：为右表)**

- 交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在 SQL 中的实现，如果 A 表有 m 行，B 表有  n 行，那么 A 和 B 交叉连接 的结果就有 m*n 行。
- 笛卡尔积：是数学中的一个概念，例如集合 A = {a,b}，集合 B = {1,2,3}，那么 A **X** B = `{<a,0>,<a,1>,<a,2>,<b,0>,<b,1>,<b,2>}`。

## 那 Mysql 的内连接、左连接、右连接有什么区别？

Mysql  的连接主要分为内连接和外连接，外连接常用的有左连接、右连接。

![image-20221120192336168](https://s1.vika.cn/space/2022/11/21/3aebc74c42cd4876975a25ec449eb88d)

- inner join 内连接、在两张表进行连接查询时，只保留两张表中完全匹配的结果集。
- left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有完全匹配的记录。
- right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。

## 说一下数据库的三大范式？

![image-20221120201858281](https://s1.vika.cn/space/2022/11/21/28916a27ca9e41eab3c88e3c2c70a2ad)

- **第一范式**：数据表中的每一列（每个字段）都不可以再拆分。例如用户表，用户地址还可以拆分成国家、身份、市，这样才符合第一范式的要求。
- **第二范式**：在第一范式的基础上，非主键列完全依赖于主键、而不能依赖于主键的一部分。例如，订单表中，存储了商品信息（商品价格、商品类型），那就需要把商品 ID 和 订单 ID 作为联合主键，才满足第二范式。

- **第三范式**：在满足第二范式的基础上，表中的非主键只依赖于主键、而不是依赖于其他非主键，例如，订单表中，就不能存储用户信息（姓名、地址）。

**三大范式的作用是为了控制数据库的冗余，是对空间的节省**，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表垮库，利用空间换时间、提升性能。

## varchar 与 char 的区别

![image-20221120194123226](https://s1.vika.cn/space/2022/11/21/747bbea7e5df41aa90409bbf490b5ba1)

**char**：

- char 表示定长字符串，定长时固定的；
- 如果插入数据的长度小于 char 的固定长度时，则用空格填充；
- 因为长度固定，所以存储速度要比 varchar 快很多、甚至能块 50 %，但正因为其长度固定，所以会占据多余的空间、是空间换时间的做法；
- 对于 char 来说，最多能存放的字符个数为 255，和编码无关

**varchar**：

- varchar 表示可变长字符串，长度是可变的；
- 插入的数据是多长，就按照多长来存储；
- varchar 在存取方面与 char 相反，它存取慢，因为长度不固定，但正因为如此，不占据多余的空间，是时间换空间的做法；
- 对于 varchar 来说，最多能存放的字符个数为 65532

日常的设计，对于长度相对固定的字符串，可以使用 char，对于长度不确定的，使用 varchar 更适合一些。

## blob 和 text 有什么区别？

- blob 用于存储二进制数据，而 text 用于存储大字符串。
- blob 没有字符集，text 有一个字符集，并且根据字符集的校对规则对值进行排序和比较

## DATETIME 和 TIMESTAMP 的异同？

相同点：

1. 两个数据类型存储时间的表现格式一致。均为 `YYYY-MM-DD HH:MM:SS`

2. 两个数据类型都包含日期和时间部分
3. 两个数据类型都可以存储微妙和小数秒（秒后 6 位小数秒）

区别：

![image-20221120201348516](https://s1.vika.cn/space/2022/11/21/48933a428cea46578d3f0c3080ec7ef7)

1. 日期范围：DATETIME 的日期范围是 `1000-01-01 00:00:00.000000` 到 `9999-12-31 23:59:59.999999` ；TIMESTAMP 的时间范围是 `1970-01-01 00:00:01.000000` UTC 到 `2038- 01-09 03:14:07.999999` UTC

2. 存储空间：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节
3. 时区相关：DATETIME 的存储空间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区
4. 默认值：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空（not null），默认值为当前时间（CURRENT_TIMESTAMP）

## MySQL 中 in 和 exists 的区别？

MySQL 中的 in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。我们可能认为 exists 比 in 语句的效率要高，这种说法其实不准确，要区分情景：

1. 如果查询的两个表大小相当，那么用 in 和 exists 差别不大。
2. 如果两个表中一个较小，一个是大表，则子查询表大的用 exists，子查询表小的用 in。
3. not in  和 not exists：如果查询语句使用了 not in，那么内外表都进行全表扫描，没有用到索引；而 not exists的子查询依然能用到表上的所以。所以无论哪个表大，用 not exists 都比 not in 要快。

## MySQL 里记录货币用什么字段类型比较好？

货币在数据库中 MySQL 常用 Decimal 和 Numric 类型表示，这两种类型被 MySQL 实现为同样的类型。他们被用于保存与货币有关的数据。

例如 salary DECIMAL（9,2），9（precision）代表将被用于存储值的总的小数位数，而2（scale）代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从 -9999999.99 到 9999999.99。

DECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二级制浮点数，以便保存那些值的小数精度。

之所以不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有一定的误差。

## MySQL 怎么存储 emoji？

MySQL 可以直接使用字符串存储 emoji。

但是需要注意的，utf8 编码是不行的，MySQL 中的 utf8 是阉割版的 utf8，它最多只用 3 个 字节存储字符，所以存储不了表情。那该怎么办？

需要使用 utf8mb4 编码。

```sql
alter table blogs modify content text CHARACTER SET utf8mb4 COLLATE
utf8mb4_unicode_ci not null;
```

## drop、delete 与 truncate 的区别？

三者都表示删除，但是三者有一些差别：

| delete   | truncate                                 | drop                           |
| -------- | ---------------------------------------- | ------------------------------ |
| 类型     | 属于 DML                                 | 属于 DML                       |
| 回滚     | 可回滚                                   | 不可回滚                       |
| 删除内容 | 表结构还在，删除表的全部或者一部分数据行 | 表结构还在，删除表中的所有数据 |
| 删除速度 | 删除速度慢，需要逐行删除                 | 删除速度快                     |

因此，在不再需要一张表的时候，用 drop；在想删除部分数据行的时候，用 delete；在保留表而删除所有数据的时候用 truncate。

## UNION 与 UNION ALL 的区别？

- 如果使用 UNION ALL，不会合并重复的记录行
- 效率 UNION 高于 UNION ALL

count（1）、count（*）与 count（列名）的区别？

![image-20221121160126332](https://s1.vika.cn/space/2022/11/21/e794aeb502084b148e5a2c7e888cc443)

执行效果：

- count（*）包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL
- count（1）包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略
