---
title: MySQL 精选面试题🔥
tag: MySQL
category:
  - 面试题
  - 数据库
article: false
---

## ACID 靠什么保证的？

A 原子性，由 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql

C 一致性，有其他三大特征保证、程序代码要保持业务上的一致性

I  隔离性，由 MVCC 来保证

D 持久性，由`内存 + redo log` 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，宕机的时候可以从 redo log 恢复

```sql
InnoDB redo log 写盘,InnoDB 事务进入 prepare 状态。
如果前面 prepare 成功,binlog 写盘,再继续将事务日志持久化到 binlog,如果持久化成功,那么 InnoDB 事务则进入 commit 状态(在 redo log 里面写一个 commit 记录)
```

redolog 的刷盘会在系统空闲时进行

## 你们数据量级多大？分库分表怎么做的？

首先分库分表分为垂直和水平两个方式，一般来说我们拆分的顺序是先垂直后水平。

- **垂直分库**

- **垂直分表**

## 👉 基础篇

### 什么是内连接、外连接、交叉连接、笛卡尔积呢？

- 内连接(inner join)：取得两张表中满足存在连接匹配关系的记录，内连接相当于左右拼表。

内连接语法结构：

```sql
select 查询字段 from 表1[inner] join 表2 on 表1.关系字段 = 表2.关系字段;(等值连接)
```

也可以写成如下的形式，连接条件写在where子句中：

```sql
select 查询字段 from 表1,表2 where 表1.关系字段=表2.关系字段;
```

- 外连接(outer join)：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表(或两张表)中不满足匹配关系的记录。(一般查询出来的数据会存在空字段)
  - **左外连接：select..from 表1 left join 表2 on 条件(表1:为左表，表2：为右表)**
  - **右外连接：select..from表1 reght join 表2 on 条件(表1:为左表，表2：为右表)**

- 交叉连接(cross join)：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在 SQL 中的实现，如果 A 表有 m 行，B 表有  n 行，那么 A 和 B 交叉连接 的结果就有 m*n 行。
- 笛卡尔积：是数学中的一个概念，例如集合 A = {a,b}，集合 B = {1,2,3}，那么 A **X** B = `{<a,0>,<a,1>,<a,2>,<b,0>,<b,1>,<b,2>}`。

### 那 MySQL 的内连接、左连接、右连接有什么区别？

Mysql  的连接主要分为内连接和外连接，外连接常用的有左连接、右连接。

![image-20221120192336168](https://s1.vika.cn/space/2022/11/21/3aebc74c42cd4876975a25ec449eb88d)

- inner join 内连接、在两张表进行连接查询时，只保留两张表中完全匹配的结果集。
- left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有完全匹配的记录。
- right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。

### 说一下数据库的三大范式？

![image-20221120201858281](https://s1.vika.cn/space/2022/11/21/28916a27ca9e41eab3c88e3c2c70a2ad)

- **第一范式**：数据表中的每一列(每个字段)都不可以再拆分。例如用户表，用户地址还可以拆分成国家、身份、市，这样才符合第一范式的要求。
- **第二范式**：在第一范式的基础上，非主键列完全依赖于主键、而不能依赖于主键的一部分。例如，订单表中，存储了商品信息(商品价格、商品类型)，那就需要把商品 ID 和 订单 ID 作为联合主键，才满足第二范式。

- **第三范式**：在满足第二范式的基础上，表中的非主键只依赖于主键、而不是依赖于其他非主键，例如，订单表中，就不能存储用户信息(姓名、地址)。

**三大范式的作用是为了控制数据库的冗余，是对空间的节省**，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表垮库，利用空间换时间、提升性能。

### varchar 与 char 的区别

![image-20221120194123226](https://s1.vika.cn/space/2022/11/21/747bbea7e5df41aa90409bbf490b5ba1)

**char**：

- char 表示定长字符串，定长时固定的；
- 如果插入数据的长度小于 char 的固定长度时，则用空格填充；
- 因为长度固定，所以存储速度要比 varchar 快很多、甚至能块 50 %，但正因为其长度固定，所以会占据多余的空间、是空间换时间的做法；
- 对于 char 来说，最多能存放的字符个数为 255，和编码无关

**varchar**：

- varchar 表示可变长字符串，长度是可变的；
- 插入的数据是多长，就按照多长来存储；
- varchar 在存取方面与 char 相反，它存取慢，因为长度不固定，但正因为如此，不占据多余的空间，是时间换空间的做法；
- 对于 varchar 来说，最多能存放的字符个数为 65532

日常的设计，对于长度相对固定的字符串，可以使用 char，对于长度不确定的，使用 varchar 更适合一些。

### blob 和 text 有什么区别？

- blob 用于存储二进制数据，而 text 用于存储大字符串。
- blob 没有字符集，text 有一个字符集，并且根据字符集的校对规则对值进行排序和比较

### DATETIME 和 TIMESTAMP 的异同？

相同点：

1. 两个数据类型存储时间的表现格式一致。均为 `YYYY-MM-DD HH:MM:SS`

2. 两个数据类型都包含日期和时间部分
3. 两个数据类型都可以存储微妙和小数秒(秒后 6 位小数秒)

区别：

![image-20221120201348516](https://s1.vika.cn/space/2022/11/21/48933a428cea46578d3f0c3080ec7ef7)

1. 日期范围：DATETIME 的日期范围是 `1000-01-01 00:00:00.000000` 到 `9999-12-31 23:59:59.999999` ；TIMESTAMP 的时间范围是 `1970-01-01 00:00:01.000000` UTC 到 `2038- 01-09 03:14:07.999999` UTC

2. 存储空间：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节
3. 时区相关：DATETIME 的存储空间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区
4. 默认值：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)

### MySQL 中 in 和 exists 的区别？

MySQL 中的 in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。我们可能认为 exists 比 in 语句的效率要高，这种说法其实不准确，要区分情景：

1. 如果查询的两个表大小相当，那么用 in 和 exists 差别不大。
2. 如果两个表中一个较小，一个是大表，则子查询表大的用 exists，子查询表小的用 in。
3. not in  和 not exists：如果查询语句使用了 not in，那么内外表都进行全表扫描，没有用到索引；而 not exists的子查询依然能用到表上的所以。所以无论哪个表大，用 not exists 都比 not in 要快。

### MySQL 里记录货币用什么字段类型比较好？

货币在数据库中 MySQL 常用 Decimal 和 Numric 类型表示，这两种类型被 MySQL 实现为同样的类型。他们被用于保存与货币有关的数据。

例如 salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从 -9999999.99 到 9999999.99。

DECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二级制浮点数，以便保存那些值的小数精度。

之所以不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有一定的误差。

### MySQL 怎么存储 emoji？

MySQL 可以直接使用字符串存储 emoji。

但是需要注意的，utf8 编码是不行的，MySQL 中的 utf8 是阉割版的 utf8，它最多只用 3 个 字节存储字符，所以存储不了表情。那该怎么办？

需要使用 utf8mb4 编码。

```sql
alter table blogs modify content text CHARACTER SET utf8mb4 COLLATE
utf8mb4_unicode_ci not null;
```

### drop、delete 与 truncate 的区别？

三者都表示删除，但是三者有一些差别：

| delete   | truncate                                 | drop                           |
| -------- | ---------------------------------------- | ------------------------------ |
| 类型     | 属于 DML                                 | 属于 DML                       |
| 回滚     | 可回滚                                   | 不可回滚                       |
| 删除内容 | 表结构还在，删除表的全部或者一部分数据行 | 表结构还在，删除表中的所有数据 |
| 删除速度 | 删除速度慢，需要逐行删除                 | 删除速度快                     |

因此，在不再需要一张表的时候，用 drop；在想删除部分数据行的时候，用 delete；在保留表而删除所有数据的时候用 truncate。

### UNION 与 UNION ALL 的区别？

- 如果使用 UNION ALL，不会合并重复的记录行
- 效率 UNION 高于 UNION ALL

### count(1)、count(*)与 count(列名)的区别？

![image-20221121160126332](https://s1.vika.cn/space/2022/11/21/e794aeb502084b148e5a2c7e888cc443)

执行效果：

- count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL
- count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL

- count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空(这里的空不是只空字符串或者 0，而是表示 null)的计数，即某个字段为 NULL 时，不统计。

执行速度：

- 列名为主键，count(列名)会比 count(1)快。

- 列名不为主键，count(1)会比 count(列名)快。
- 如果表多个列并且没有主键，则 count(1)的执行效率优于 count(*)。
- 如果有主键，则 select count(主键)的执行效率是最优的。
- 如果表只有一个字段，则 select count(*)最优。

### 一条 SQL 查询语句的执行顺序？

![image-20221123101717715](https://s1.vika.cn/space/2022/11/23/f960ccdecf254a8f8b6e69b617daa85a)

1. FROM：对 FROM 子句中的左表`<left table>` 和右表 `<right table>` 执行笛卡尔积，产生虚拟表 VT1
2. ON：对虚拟表 VT1 应用 ON 筛选，只有那些符合 `<join_condition>` 的行才被插入虚拟表 VT2中

## 👉 架构篇

### 说说 MySQL 的基础架构？

![](https://s1.vika.cn/space/2022/11/23/6777b6f39efc4390831e76b3ab95f72d)

MySQL 逻辑架构图主要分为三层：

- 客户端：最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。
- Server 层：大多数 MySQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数(例如，日期、时间、数学和加密函数)、所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
- 存储引擎层：第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取，Server 层通过 API 与 存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。

### 一条 SQL 查询语句在 MySQL 中如何执行的？

- 先检查语句`是否有权限`，如果没有权限，直接返回错误信息，如果有权限会先查询缓存(MySQL 8.0 版本之前)。
- 如果没有缓存，分析器进行 `语法分析`，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键字是否正确等等。
- 语法解析之后，MySQL 的服务器会对查询的语句进行优化，确定执行的方案。
- 完成查询优化之后，按照生成的执行计划 `调用数据库引擎接口`，返回执行结果。

## 👉 存储引擎篇

### MySQL有哪几种数据存储引擎？有什么区别？

MySQL 通过 show ENGINES 指令可以看到所有支持的数据库存储引擎。

```sql
show ENGINES
```

![](https://s1.vika.cn/space/2022/11/21/9ce1d66f2cf74fb7b71687b6a321a060)

其中最为常用的是 `MyISAM` 和 `InnoDB`

MyISAM 和 InnoDB 的区别：

1. 存储文件。MyISAM 每个表有两个文件，MYD 和 MYISAM 文件。其中，MYD 是数据文件，MyISAM 是索引文件。而 InnoDB 每个表只有一个文件：ibd。
2. InnoDB 支持事务，支持行级锁，支持外键。
3. InnoDB 支持 XA 事务
4. InnoDB 支持 Savepoints：部分回滚

```sql
XA START 'test';
INSERT ....
XA END 'test';
XA PREPARE 'test';
XA COMMIT 'test'
XA ROLLBACK 'test';
```

### MySQL 有哪些常见存储引擎？

![image-20221123124958565](https://s1.vika.cn/space/2022/11/23/ec9b88705bbf4221bf5e3dd0cc0a6a87)

主要存储引擎以及功能如下：

| 功能         | MyISAM | MEMORY | InnoDB |
| ------------ | ------ | ------ | ------ |
| 存储限制     | 256TB  | RAM    | 64TB   |
| 支持事务     | No     | No     | Yes    |
| 全文支持索引 | Yes    | No     | Yes    |
| 支持树索引   | Yes    | Yes    | Yes    |
| 支持哈希索引 | Yes    | Yes    | Yes    |
| 支持数据缓存 | No     | N/Y    | Yes    |
| 支持外键     | No     | No     | Yes    |

MySQL 2.5 之前，默认存储引擎是 MyISAM，5.5 之后变成了 InnoDB。

> InnoDB 支持的哈希索引是自适应的，InnoDB 会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。

> MySQL 5.6 开始 InnoDB 支持全文索引。

### 那存储引擎应该怎么选择？

大致上可以这么选择：

- 大多数情况下，使用默认的 InnoDB 就够了。如果再提供提交、回滚和恢复的事务安全(ACID 兼容)能力，并要求实现并发控制，InnoDB 就是比较靠前的选择了。
- 如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。
- 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MYEMORY 引擎中 ，MySQL 中使用该引擎作为临时表，存放查询的中间结果。

使用哪一种引擎可以根据需要灵活选择，因为存储引擎是基于表的，所以一个数据库中多个表可以使用不同的存储引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。

### InnoDB 和 MyISAM 主要有什么区别？

PS：MySQL 8.0 都开始慢慢流行了，如果不是面试，MyISAM 其实可以不用怎么了解。

![image-20221123133458389](https://s1.vika.cn/space/2022/11/23/8f203f52af32436eab4161088db70e12)

1. 存储结构：每个 MyISAM 在磁盘上存储三个文件；InnoDB 所有的表都保存在一个数据库文件中(也可能是多个文件，或者是独立的表空间文件)，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB。
2. 事务支持：MyISAM 不提供事务支持；InnoDB 提供事务支持事务，具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全特性。
3. 最小锁粒度：MyISAM 只支持表级锁，更新时会锁住整张表，导致其他查询和更新都会被阻塞；InnoDB 支持行级锁。
4. 索引类型：MyISAM 索引为聚簇索引，数据结构是 B 树；InnoDB 的索引是非聚簇索引，数据结构是 B+ 树。
5. 主键必须：MyISAM 允许没有任何索引和主键的表存在；InnoDB 如果没有设定主键或者非空唯一索引，**就会自动生成一个 6 字节的主键(用户不可见)**，数据是主索引的一部分，附加所有保存的是主索引的值。
6. 表的具体行数：MyISAM 保存了表的总行数，如果 select count(*) from table；会直接取出该值；InnoDB 没有保存表的总行数，如果使用 select count(*) from table；就会遍历整个表；但是在加了 where 条件之后，MyISAM 和 InnoDB 处理的方式都一样。
7. 外键支持：MyISAM 不支持外键；InnoDB 支持外键。

### 能说下 myisam 和 innodb 的区别吗？

myisam 引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于大量查询少量插入的场景来使用，而且 myisam 不支持外键，并且索引和数据是分开存储的。

innodb 是基于 B+Tree 索引来建立的，和 myisam 相反，它支持事务、外键，并且通过 MVCC(多版本并发控制) 来支持高并发，索引和存储数据是一起的。

### 简述 Mysql 中索引类型及对数据库的性能的影响

普通索引：允许被索引的数据列包含重复的值。

唯一索引：可以保证数据记录的唯一性。

主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。

联合索引：索引可以覆盖多个数据列，如像 INDEX(colunmA，columnB)索引。

全文索引：通过建立 `倒排索引`，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术，可以通过 ALTER TABLE table_name ADD FULLTEXT(column)创建全文索引

索引可以极大的提高数据的查询速度

通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

但是会降低插入、删除、更新表的速度，因为在执行这些操作时，还要操作索引文件

索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果需要建立聚簇索引，那么需要的空间就会更大，如果非聚簇索引很多，一旦聚簇索引改变，那么所有非聚簇索引都会跟着变。

## 👉 日志篇

### MySQL 日志文件有哪些？分别介绍下作用？

![image-20221127190255261](https://s1.vika.cn/space/2022/11/27/29faa666a85d483694d76db5e70475d7)

MySQL 日志文件有很多，包括：

- 错误日志（error log）：错误日志对 MySQL 的启动、运行、关闭过程进行了记录，能帮助定位 MySQL 问题。
- 慢查询日志（slow query log）：慢查询日志是用来记录执行时间超过 long_query_time 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。
- 一般查询日志（general log）：一般查询日志记录了所有对 MySQL 数据库请求的信息，无论请求是否正确执行。
- 二进制日志（bin log）：关于二进制日志，它记录了数据库所有执行的 DDL 和 DML 语句（除了数据查询语句 select、show 等），以事件形式记录并保存在二进制文件中。

还有两个 InnoDB 存储引擎特有的日志文件：

- 重做日志（redo log）：重做日志至关重要，因为他们记录了对于 InnoDB 存储引擎的事务日志。
- 回滚日志（undo log）：回滚日志同样也是 InnoDB 引擎提供的日志，顾名思义，回滚日志的作用就是对数据库进行回滚。当事务对数据库进行修改，InnoDB 引擎不仅会记录 redo log，还会生成对应的  undo log 日志；如果事务执行失败或者调用了 rollback，导致事务需要回滚，就可以利用 undo log 中的信息将数据回滚到修改之前的样子。

### binlog 和 redo log 有什么区别？

- bin log 会记录所有与数据库相关的日志记录，包括 InnoDB、MyISAM 等存储引擎的日志、而 redo log 只记 InnoDB 存储引擎的日志。
- 记录的内容不同，bin log 记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而 redo log 记录的是关于每个页（Page）的更改的物理情况。
- 写入的时间不同，bin log 仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有 redo ertry 被写入 redo log 中。
- 写入的方式也不同，redo log 是循环写入和擦除，bin log 是追加写入，不会覆盖已经写入的文件。

### 一条更新语句怎么执行的了解吗？

更新语句的执行是 Server 层和引擎层配合完成，数据库除了要写入表中，还要记录相应的日志。

![image-20221127194314951](https://s1.vika.cn/space/2022/11/27/174b7a72ba4d45ed948a039c3632995d)

1. 执行器先找引擎获取 id=2 这一行。id 是主键，存储引擎检索数据，找到这一行。如果 id=2 这一行所在的数据页本本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N + 1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时把这个更新记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

从上图可以看出，MySQL 在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储：同时在服务层对 binlog 进行写入，在 InnoDB 内进行 redo log 的写入。

不仅如此，在对 redo log 写入时有两个状态的提交，一是 binlog 写入之前 `prepare` 状态的写入，二是 binlog 写入之后 `commit` 状态的写入。

### 那为什么要两阶段提交呢？

为什么要两阶段提交呢？直接提交不行吗？

我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入 redo log，后写入 binlog；要么先写入 binlog ，后写入 redolog。这两种方式的提交都会导致原先的数据库的状态和被恢复后的数据库的状态不一致。

先写入 **redo log**，后写入 **binlog**：

在写完 redo log 之后，数据此时具有 `crash-safe` 能力，因此系统崩溃，数据会恢复成事务开始之前的状态。但是，若在 redo log 写完时候，binlog 写入之前，系统发生宕机。此时 binlog 没有对上面的更新语句进行保存，导致当使用 binlog 进行数据库的备份或者恢复时，就少了上述的更新语句。从而使得 `id=2` 这一行的数据没有被更新。

![image-20221127200721772](https://s1.vika.cn/space/2022/11/27/9463b1d5ca4045b2bbe86c3b7f6f2576)

先写入 binlog，后写入 redo log：

写完 binlog 之后，所有的语句都被保存，所以通过 binlog 复制或者恢复出来的数据库中 id=2 这一行的数据会被更新为 a=1。但是如果在 redo log 写入之前，系统崩溃，那么 redo log 中记录的这个事务会无效，导致实际数据库中 `id=2` 这一行的数据并没有更新。

![image-20221127201027945](https://s1.vika.cn/space/2022/11/27/4c1e170b3b7a460ea754c7b11f184e78)

简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交事务就是让这两个状态保持逻辑上的一致。

### redo log 怎么刷入磁盘的知道吗？

redo log 的写入不是直接落到磁盘，而是在内存中设置了一片称为 `redo log buffer` 的连续内存空间，也就是 `redo 日志缓冲区`。

![ ](https://s1.vika.cn/space/2022/11/28/65490421f76143cb854e4b0d287a32e3)

> 什么时候会刷入磁盘？

在如下的一些情况中，log buffer 的数据会刷入磁盘：

- log buffer 空间不足时

log buffer 的大小是有限的，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。如果当前写入 log buffer 的 redo 日志量已经占满了 log buffer 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。

- 事务提交时

在事务提交时，为了保证持久性，会把 log buffer 中的日志全部刷到磁盘。注意，这时候，除了本事务的，可能还会刷入其他事务的日志。

- 后台线程输入

有一个后台线程，大约每秒都会刷新一次 `log buffer` 中的 `redo log` 到磁盘

- 正常关闭服务时块
- 触发 checkpoint 规则

重做日志缓存、重做日志都是以块（block）的方式进行保存的，称之为重做日志块（redo log block），块的大小是固定的 512 字节。我们的 redo log 它是固定大小的，可以看作是一个逻辑上的 log group，由一定数量的 log block 组成。

![image-20221128082157405](https://s1.vika.cn/space/2022/11/28/d641b3b27c004281b738a30debc3de46)

它的写入方式是从头到尾开始写，写到末尾又回到开头循环写。

其中有两个标记位置：

`write pos` 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。`checkpoint`  是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到磁盘。

![image-20221128082711155](https://s1.vika.cn/space/2022/11/28/bde68890eb9b47028c2b0a0cba8de024)

当 `write_pos` 追上 `checkpoint` 时，表示 redo log 日志已经写满。这时候就不能接着往里写数据了，需要执行 `checkpoint` 规则腾出可写空间。

所谓 checkpoint 规则，就是 checkpoint 触发后，将 buffer 中日志都刷到磁盘。

## 👉 SQL 优化篇

### 慢 SQL 如何定位呢？

慢 SQL 的监控主要通过两个途径：

![image-20221128083108377](https://s1.vika.cn/space/2022/11/28/a4a99e329d7747ae91e6ac8d116ad8dd)

- 慢查询日志：开启 MySQL 的慢查询日志，再通过一些工具比如 mysqldumpslow 去分析对应的慢查询日志，当然现在一般的云厂商都提供了可视化的平台。
- 服务监控：可以在业务的基建中加入对慢 SQL 的监控，常见的方案有字节码插桩、连接池扩展、ORM 框架过程，对服务运行中的慢 SQL 进行监控和告警。

### 有哪些方式优化慢 SQL？

慢 SQL 的优化，主要从两个方面考虑，SQL 语句本身的优化，以及数据库设计的优化。

![image-20221128083715289](https://s1.vika.cn/space/2022/11/28/404cf0f7237d49f38ab24ce9a9356457)

**避免不要的列**

这个是老生常谈，但还是经常会出问题，SQL 查询的时候，应该只查询需要的列，而不要包含外的列，像 `select *`  这种写法应该尽量避免。

#### **分页优化**

在数据量比较大，分页比较深的情况下，需要考虑分页的优化。

例如：

```sql
select * from table where type = 2 and level = 9 order by id asc limit 190289,10;
```

优化方案：

- **延迟关联**

先通过 where 条件提取主键，在将该表与原数据表关联，通过主键 id 提出数据行，而不是通过原来的二级索引提取数据行

例如：

```sql
select a.* from table a,
 (select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b
 where a.id = b.id
```

- **书签方式**

书签方式就是找到 limit 第一个参数对应的主键值，根据这个主键值再去过滤并 limit

例如：

```sql
select * from table where id >
 (select * from table where type = 2 and level = 9 order by id asc limit 190
```

#### 索引优化

合理地设计和使用索引，是优化慢 SQL 的利器。

**利用覆盖索引**

InnoDB 使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引

例如对于如下查询：

```sql
select name from test where city='上海'
```

我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取

```sql
alter table test add index idx_city_name (city, name);
```

**低版本避免使用 or 查询**

在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来代替，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入索引合并，解决了这个问题。

**避免使用 != 或者 <> 操作符**

SQL 中，不等于操作符会导致查询引擎放弃查询索引，引入全表扫描，即使比较的字段上有索引

解决方法：通过把不等于操作符改成 or，可以使用索引，避免全表扫描

例如，把 `column<>’aaa’ ，改成column>’aaa’ or column<’aaa’` ，就可以使⽤索引了

**适当使用前缀索引**

适当地使用前缀索引，可以降低索引的空间占用，提高索引的查询效率。

比如，邮箱的后缀都是固定的“`@xxx.com`”，那么类似这种后面几位为固定的字段就非常适当定义为前缀索引

```sql
alter table test add index index2(email(6));
```

**PS：需要注意的是，前缀索引也存在缺点，MySQL 无法利用前缀索引来做 order by 和 group by 的操作，也无法作为覆盖索引**

**避免列上函数运算**

要避免在列字段上进行算术运算或者其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率

```sql
select * from test where id + 1 = 50;
select * from test where month(updateTime) = 7;
```





**正确使用联合索引**

使用联合索引的时候，注意最左匹配原则。

#### JOIN 优化

**优化子查询**

尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大

**小表驱动大表**

关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL 内部会遍历驱动表，再去连接被驱动表。

比如 left join，左表就是驱动表，A 表小于 B 表，建立连接的次数就少，查询速度就被加快了。

```java
select name from A left join B ;
```

**适当增加冗余字段**

增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所以可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略。

**避免使用 JOIN 关联太多的表**

《阿里巴巴 Java 开发手册》规定不要 join 超过三张表，第一 join 太多降低查询的速度，第二 join 的 buffer 会占用更多的内存。

如果不可避免要 join 多张表，可以考虑使用数据库异构的方式异构到 ES 中查询。

#### 排序优化

利用索引扫描做排序

MySQL 有两种方式生成有序结果：其一是对结果进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的

但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机 IO，通常会比顺序全表扫描还慢

因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查询行

例如：

```sql
- -建 ⽴ 索 引 （date,staff_id,customer_id）
select staff_id, customer_id from test where date = '2010-01-01' order by
staff_id,customer_id;
```

只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序

#### UNION 优化

条件下推

MySQL 处理 union 的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在 union 查询中都会失效，因为它无法利用索引

最好手工将 where、limit 等子句下推到 union 的各个子查询中，以便优化器可以充分利用这些条件进行优化

此外，除非确实需要服务器去重，一定要使用 union all，如果不加 all 关键字，MySQL 会给临时表加上 distinct 选项，这会导致对整个临时表做唯一性检查，代价很高。

### 怎么看执行计划（explain），如何理解其中各个字段的含义？

explain 是 sql 优化的利器，除了优化慢 sql，平时的 sql 编写，也应该先 expain，查看一下执行计划，看看是否有优化的空间。

直接在 select 语句之前增加 `explain`关键字，就会返回执行计划的信息

![](https://s1.vika.cn/space/2022/12/15/a3012181c14d4cfc9f860ce055a72f03)

1. **id **列：MySQL 会为每个 select 语句分配一个唯一的 id 值

2.**select_type** 列，查询的类型，根据关联、union、子查询等等分类，常见的查询类型有 SIMPLE、PRIMARY。

3.**table** 列：表示 explain 的一行正在访问哪个表。

4.**type** 列：最重要的列之一。表示关联类型或访问类型，即 MySQL 决定如何查找表中的行。

性能从最优到最差分别为：system > const > eq_ref > ref > fulltext > ref_or_null > index >merge > unique_subquery > index_subquery > range > index > ALL

- system

`system`：当表仅有一行记录时（系统表），数据量很少，往往不需要进行磁盘 IO，速度非常快

- const

`const`：表示查询时命中 `primary key` 主键或者 `unique` 唯一索引，或者被连接的部分是一个常量（`const`）值。这类扫描效率极高，返回数据量少，速度非常快。

- eq_ref

`eq_ref`：查询时命中主键 `primary key` 或者 `unique key` 索引，`type` 就是 `eq_ref`。

- ref_or_null

`ref_or_null`：这种连接类型类似于 ref，区别在于 `MySQL` 会额外搜索包含 `NULL` 值的行。

- index_merge

`index_merge`：使用了索引合并优化方法，查询使用了两个以上的索引

- unique_subquery

`unique_subquery`：区别于 unique_query，用于非唯一索引，可以返回重复值。

- range

`range`：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在 `where` 语句中使用 `between...and`、`<`、`>`、`<=`、`in` 等条件查询 `type` 都是 `range`

- index

`index`：`Index` 与 `ALL` 其实都是读全表，区别在于 index 是遍历索引树读取，而 `ALL` 是从硬盘中读取。

- ALL

就不用多说了，全表扫描。

6.possible_keys 列：显示查询可能使用哪些索引来查找，使用索引优化 sql 的时候比较重要。

7.key 列：这一列显示 MySQL 实际采用哪个索引来优化对该表的访问，判断索引是否失效的时候常用。

8.key_len 列：显示了 MySQL 使用



### MySQL 执行计划怎么看？

**执行计划就是 sql 的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数**

EXPLAIN SELECT * from  A where X=? and Y=?

![image-20221112123752976](https://s1.vika.cn/space/2022/11/21/d0b8ac6923f24e6a92ed2308ee978c67)

1. id：是一个有顺序的编号，是查询的顺序号，有几个 select 就是显示几行，id 的顺序是按 select 出现的顺序增长的。id 列的值越大执行优先级越高越先执行，id 列的值相同则从上往下执行，id 列的值为 NULL 最后执行。
2. selectType 表示查询中每个 select 子句的类型
   - SIMPLE：表示此查询不包含 UNION 查询或子查询
   - PRIMARY：表示此查询的最外层的查询(包含子查询)
   - SUBQUERY：子查询中的第一个 SELECT
   - UNION：表示此查询是 UNION 的第二或随后的查询
   - DEPENENT UNION：UNION 中的第二个或后面的查询语句，取决于外面的查询
   - UNION RESULT，UNION 的结果
   - DEPENDENT SUBQUERY：子查询的第一个 SELECT，取决于外面的查询，即子查询依赖于外层查询的结果
   - DERIVER：衍生，表示导出表的 SELECT(FROM 子句的子查询)
3. table：表示该语句查询的表
4. **type：**优化 sql 的重要字段，也是我们判断 sql 性能的优化程度重要指标，他的取值类型范围：
   - const：通过索引一次命中，匹配一行数据
   - system：表中只有一行数据，相当于系统表(效率优于 const)
   - eq_ref：唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配
   - ref：非唯一性索引扫描，返回匹配某个值的所有
   - range：只检索给定范围的行，使用一个索引来选择行，一般用 between、<、>；
   - index：只遍历索引树；
   - ALL：表示全表扫描，这个类型的查询是性能最差的查询之一。那么基本就是随着表的数量增多，执行效率越慢。(没有走索引)

**执行效率：**

**ALL < index < range < ref < eq_ref < const < system。最好是避免 ALL 和 index**

5. possible_keys：它表示 Mysql 在执行该 sql 语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。
6. key：此字段是 mysql 在当前查询时所真正使用到的索引，它是 possible_keys 的子集
7. key_len：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是我们优化 sql 时，评估索引的重要指标。
8. rows：mysql 查询优化器根据统计信息，估算该 sql 返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大
9. filtered：返回结果的行占需要读取的行(rows 列的值)的百分比，就是百分比越高，说明需要查询到数据越准确，百分比越小，说明查询到的数据量大，而结果集很少
10. extra
    - using filesort：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果，一般有 using filesort 都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。
    - using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。
    - using temporary：查询有使用临时表，一般出现于排序，分组和多表 join 的情况，查询效率不高，建议优化。
    - using where：sql 使用了 where 过滤，效率较高



## 👉 索引篇

### 什么是B+树？为什么B+树成为主要的SQL数据库的索引实现？

- **什么是 B+Tree?**

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi + 1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于 keyi+1。

![img](https://s1.vika.cn/space/2022/11/21/0db487dddbc141269cc266f6a0745933)

- **为什么是 B+ Tree？**
  - 为了减少磁盘读取次数，决定了树的高度不能高，所以必须是先 B-Tree；
  - 以页为单位读取使得一次 I/O 就能完全载入一个节点，且相邻的节点也能够被预先载入；所以数据放在叶子节点，本质上是一个 Page 页；
  - 为了支持范围查询以及关联关系，页中数据需要有序，且页的尾部节点指向下一个页的头部；
- **B+ 树索引可以分为聚簇索引和非聚簇索引？**

1. 主索引就是聚簇索引(也称为聚集索引，clustered index)
2. 辅助索引(有时也称非聚簇索引或二级索引，secondary index，non-clustered index)。

![img](https://s1.vika.cn/space/2022/11/21/8b1cbc2f2c814db8846a1cc0bc4021e3)

如上图，**主键索引的叶子节点保存的是真正的数据。而辅助索引叶子节点的数据区保存的是主键索引关键字的值**

假设要查询 name == C 的数据，其搜索过程如下：

​	a)先在辅助索引中通过 C 查询最后找到主键 id = 9；

​	b)在主键索引中搜索 id 为9的数据，最终在主键索引的叶子节点中获取到真正的数据。所以 通过辅助索引进行检索，需要检索两次索引。

之所以这样设计，一个原因就是：如果和 MyISAM 一样在主键索引和辅助索引的叶子节点中都存放数据行指针，一旦数据发生迁移，则需要去重新组织维护所有的索引。

### MySQL 索引结构是怎么样的？聚簇索引和非聚簇索引又是什么？

二叉树 —> AVL 平衡数 —> 红黑树 —> B-树 —> B+ 树

二叉树：每个节点最多只有两个子节点，左边的子节点都比当前节点小，右边的子节点都比当前节点大。

AVL 平衡树：树中任意节点的两个子树的高度差最大为 1

红黑树：

1. 每个节点都是红色或者黑色
2. 根节点是黑色
3. 每个叶子节点都是黑色的空节点。
4. 红色节点的父子节点都必须是褐色。
5. 从任一节点到其每个叶子的所有路径都包含相同的黑色节点

B-树 ：

1. B-树的每个非叶子结点的子节点个数都不会超过 D(这个 D 就是 B-树的阶)
2. 所有的叶子节点都在同一层。
3. 所有节点关键字都是按照递增顺序来排列。

B+树

1. 非叶子节点不存储数据，只进行数据索引。
2. 所有数据都存储在叶子节点当中。
3. 每个叶子节点都存有相邻叶子节点的指针。
4. 叶子节点按照本身关键字从小到大排序。

**聚簇索引就是数据和索引是在一起的，而非聚簇索引就是数据和索引不在一起**

MyISAM 使用的是非聚簇索引，树的子节点上的 data 不是数据本身，而是数据存放的地址。InnoDB 采用的是聚簇索引，树的叶子节点上的 data 就是数据本身。

聚簇索引的数据物理存放顺序和索引顺序是一致的，所以一个表当中只能有一个聚簇索引，而非聚簇索引可以有多个。

InnoDB 中，如果表定义了 PK，那么 PK 就是聚簇索引。如果没有 PK，就会找第一个非空的 unique 列作为聚簇索引。否则，InnoDB 会创建一个 隐藏的 row-id 作为聚簇索引。

Mysql 的覆盖索引和回表

- 如果只需要在一颗索引树上就可以获取 SQL 上所需的所有列，就不需要再回表查询，这样查询速度就可以更快。
- 实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中 。

```sql
user(PK id,name,sex)
select count(name) from user;  —> 在 name 字段上建立一个索引。
select id,name,sex from user;  —> 将 name 上的索引升级成为 (name,sex)的联合索引
```

### MySQL 索引的数据结构，各自优劣

索引的数据结构和具体索引引擎的实现相关，在 Mysql 中使用较多的索引有 Hash 索引，B+树索引等，**InnoDB 存储引擎的默认索引实现为：B+树索引。**对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单表记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择B树索引

**B+树索引：**

B+树是一个平衡多叉树，从根节点到每个叶子节点的高度值不超过1，而且同层级的节点间有指针互相链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。

![](https://s1.vika.cn/space/2022/11/21/6bb686de34bd4aa9b05222a8af9a4461)

**哈希索引：**

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到了叶子节点逐级查找，只需要一次哈希算法即可立即定位到响应的位置，速度非常快

![](https://s1.vika.cn/space/2022/11/21/60ef681f077441c89cb6dc434ed91fd2)

- keys：代表创建索引的列值；

- buckets： 就是计算出来的hash值和对应的数据的物理位置组成的hash表；

- entries：就是代表具体的数据行；

创建hash索引后，会为每个键值通过特定的算法计算出一个哈希码(hash code)，需要注意的是不同的键值计算出来的hash值可能是相同的，例上图上的 John Smith 和 Sandra Dee 算出来的hash值都是152，然后找到 hash 值为152在hash表中的存储数据的物理位置，这个位置对应着两条数据也(就是 John Smith 521-1234 和 Sandra Dee 521-9655)，然后再次遍历这两条数据，找到需要的数据，这就解释了为啥 hash 冲突严重了。

如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提是键值都是唯一的。如果键值不是唯一的，就需要找到该键所在位置，然后再根据链表往后扫描，直到找到响应的数据。

如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能不连续了，就没办法再利用索引完成范围查询检索。

哈希索引也没办法利用索引完成排序，以及 like 'xxx%' 这样的部分模糊查询(这种部分模糊查询，其实本质也是范围查询)；

哈希索引也不支持多级联合索引的最左匹配规则；

B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。

### B 树和 B+ 数的区别，为什么 MySQL 使用 B+ 树？

B 树的特点：

1. 节点排序
2. 一个节点可以存多个元素，多个元素也排序了

B+ 树的特点：

1. 拥有 B 树的特点
2. 叶子节点之间有指针
3. 非叶子节点上的元素在叶子节点都冗余了，也就是叶子节点中存储了所有元素，并且排好顺序

Mysql 索引使用的是 B+ 树，因为索引是用来加快查询的，而 B+ 数通过对数据进行排序所以是可以通过查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得 B+ 树的高度不会太高，在 Mysql 中一个 Innodb 页就是一个 B+ 树节点，一个 Innodb 页默认 16kb，所以一般情况下一颗两层 B+ 树可以存 2000万行左右的数据，然后通过利用 B+ 树叶子节点存储了所有数据并进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等 SQL 语句。

### 说下 MySQL 索引有哪些吧？

索引在什么层面？

首先，索引是在**存储引擎层实现**的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现

有哪些？

- **B+Tree 索引**

是大多数 MySQL 存储引擎的默认索引类型。

- **哈希索引**
  - 哈希索引能以 O(1) 时间进行查找，但是失去了有序性；
  - innoDB 存储引擎有一个特殊功能叫"自适应哈希索引"，当某个索引值被使用的非常频繁，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
- **全文索引**
  - MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。
  - 全文索引一般使用倒排索引实现，它记录者关键词到其所在的文档的映射
  - InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。
- **空间数据索引**
  - MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度进行组合查询。

### 那你知道什么是覆盖索引和回表吗？

覆盖索引指是在一次查询中，如果**一个索引包含或者说覆盖所有需要查询的字段的值**，我们就称之为覆盖索引，而不再需要回表查询。

而要确定一个查询是否是覆盖索引，我们只需要 explain sql 语句看 Extra 的结果是否是"Using index"即可。

比如：

```sql
explain select * from user where age=1; // 查询的name无法从索引数据获取
explain select id,age from user where age=1; //可以直接从索引获取
```

## 👉 锁相关

### MySQL 锁的类型有哪些呢？

**说两个维度**：

- 共享锁(简称 S 锁)和排他锁(简称 X 锁)
  - **读锁**是共享的，可以通过 lock in share mode 实现，这时候只能读不能写。
  - **写锁**是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁两种。
- 表锁和行锁
  - **表锁**会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如 alter 修改表结构的时候去锁表。
  - **行锁**又可以分为乐观锁和悲观锁
    - 悲观锁可以通过 for update 实现
    - 乐观锁可以通过版本号实现

**两个维度结合来看：**

- 共享锁(行锁)：Shared Locks
  - 读锁(s 锁)，多个事务对于同一个数据可以共享访问，不能操作修改
  - 使用方法 ：
    - 加锁：select * FROM table WHERE id = 1 LOCK IN SHARE MODE
    - 释放：COMMIT/ROLLBACK
- 排他锁(行锁)：Exclulsive Locks
  - 写锁(X 锁)，互斥锁/独占锁，事务获取一个数据 X 锁，其他事务就不能获取该行的读锁和写锁(s锁、X 锁)，只有获取了该排他锁的事务是可以对数据行进行读取和修改
  - 使用方法：
    - DELETE/UPDATE/INSERT --加锁
    - SELECT * FROM table WHERE ... FOR UPDATE --加锁
    - COMMIT/ROLLBACK --释放锁
- 意向共享锁(IS)
  - 一个数据行加共享锁前必须先取得该表的 IS 锁，意向共享锁之间是可以相互兼容的；意向排他锁(IX)一个数据加排他锁前必须先取得该表的 IX 锁，意向排他锁之间是可以互相兼容的；意向锁(IS、IX)是 InnoDB 引擎操作数据之前自动加的，不需要用户干预；意义：当事务操作需要锁表时，只需判断意向锁是会否存在，存在时则可快速返回表不能启用表锁
  - 意向共享锁(IS 锁)(表锁)：Intention Shared Locks
    - 表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的 IS 锁。
  - 意向排他锁(IX 锁)(表锁)：Intention Exclusive Locks
    - 表示事务准备给数据加入排它锁，说明事务在一个数据行加排在他锁前必须先获取该表的 IX 锁。

## 👉 事务篇

### Innodb 是如何实现事务的？

Innodb 通过 Buffer Pool，LogBuffer，Redo Log，Undo Log 来实现事务，以一个 upload 语句为例：

1. Innodb 在收到一个 update 语句后，会先根据条件找到数据所在页，并将该页缓存在 Buffer Pool 中
1. 执行 update 语句，修改 Buffer Pool 中的数据，也就是内存中的数据
1. 针对 update 语句生成一个 RedoLog 对象，并存入 LogBuffer 中
1. 针对 update 语句生成 undoLog 日志，用于事务回滚
1. 如果事务提交，那么则把 RedoLog 对象进行持久化，后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中
1. 如果事务回滚，则利用 undoLog 日志进行回滚

### 什么是 MVCC？ 说说 MySQL 实现 MVCC 的原理？

- **什么是 MVCC？**

MVCC，全称 Multi-Version Concurrency Control，即`多版本并发控制`。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

在 Mysql 的 InnoDB 引擎中就是指在`已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)`这两种隔离级别下的事务对于 SELECT 操作会访问版本链中的记录的过程。

这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。

- **MySQL 的 InnoDB 引擎实现 MVCC 的3个基础点**

1. **隐式字段**

![img](https://s1.vika.cn/space/2022/11/21/71cf6ec8cd494a6ab9c54fc58446bf4c)

如上图，DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键；DB_TRX_ID 是当前操作该记录的事务 ID；而 DB_ROLE_PTR 是一个回滚指针，用于配合 undo 日志，指向上一个旧指针；delete flag 没有展示出来。

2. **undo log**

![img](https://s1.vika.cn/space/2022/11/21/0b569fd897324ce7a70d390aae11e1d5)

从上面，我们就可以看出，不同事务或者相同事务的同一记录的修改，会导致该记录的 undo log 成为一条记录版本线性表，即链表，undo log 的链首就是最新的旧记录，链尾就是最早的旧记录

3. **ReadView**

已提交读和可重复读的区别就在于它们生成 ReadView 的策略不同。

ReadView 中主要有两个列表来存储我们系统中当期那活跃着的读写事务，也就是 begin 了还未提交的事务。通过这个列表来判断记录的某个版本是否对当期事务可见。假设当前列表里的事务 id 为[80,100].

 	a) 如果你要访问的记录版本的事务 id 为 50，比当前列表最小的 id 80 小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。
 	
 	b) 如果你要访问的记录版本的事务 id 为 90，发现此事务在列表 id 最大值和最小值之间，那就判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能访问，如果不在那说明事务已经提交，所以此版本可以被访问。

​	c) 如果你要访问的记录版本的事务 id 为110，那比事务列表最大 id 100 都大，那说明这个版本是在 ReadView 生成之后才发生的，所以不能被访问。

这些记录都是去 undo log 链里面找的，先找最近记录，如果最近这一条记录事务 id 不符合条件，不可见的话，再去找上一个版本比较当前事务的 id 和这个版本事务 id 能不能访问，以此类推直到返回可见的版本或者结束。

- **举个例子** ，在已提交读隔离级别下

比如此时有一个事务 id 为100的事务，修改了 name，使得 name 等于小明2，但是事务还没提交，则此时的版本链是

![img](https://s1.vika.cn/space/2022/11/21/a59d3f8720ff42c98f3222056d18c267)

那此时另一个事务发起了 select 语句要查询 id 为1的记录，那此时生成的 ReadView 列表只有[100]。那就去版本链找，首先肯定先找最近的一条，发现 trx_id 是100，也就是 name 为小明2的那条记录，发现在列表内，所以不能访问。

这时候就通过指针继续找下一条，name 为小明1的记录，发现 trx_id 是60，小于 列表中的最小 id，所以可以访问，访问结果为小明1.

那这个时候我们把事务 id 为100的事务提交了，并且新建一个事务 id 为110也修改 id 为1的记录，并且不提交事务

![img](https://s1.vika.cn/space/2022/11/21/aa0c7fd158044988b8c31eb663920369)

这时候版本链就是

![img](https://s1.vika.cn/space/2022/11/21/2913a7b1170140099af6cd6aa150fa98)

这时候之前那个 select 事务又执行了一次查询，要查询  id 为1的记录。

**已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的 ReadView，而可重复读隔离级别则在第一次读的时候生成一个 ReadView，之后的读都复用之前的 ReadView**。

1. 如果你是已提交读隔离级别，这时候你会重新生成一个 ReadView，那你的活动事务列表中的值就变了，完成了[110]。按照以上的说法，你去版本链通过 trx_id 对比查找合适的结果就是小明2.

2. 如果你是可重复读隔离级别，这时候你的 ReadView 还是第一次 select 时候生成的 ReadView，也就是列表的值还是[100]。所以 select 的结果是小明1。所以第二次 select 结果和第一次一样，所以叫可重复读！

这就是 Mysql 的 MVVC，通过版本链，实现多版本，可并发读-写，写-读。通过 ReadView 生成策略的不同实现不同的隔离级别。

## 👉 高可用/性能篇

### Mysql 的集群如何搭建的？读写分离是怎么做的？

Mysql 主从集群的搭建原理：

1. master 将操作语句记录到 binlog (记录的是每一步的数据操作)日志中

2. salve 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变

3. salve 开启两个线程：IO 线程和 SQL 线程

   - IO 线程：负责读取 master 的 binlog 内容到中继日志 relay log 里


   - SQL 线程：负责从 relay log 日志里读出 binlog 内容，并更新到 slave 的数据库里(保证数据一致)

![](https://s1.vika.cn/space/2022/11/21/d2467e62fdd54cc195ce74dace2f60de)

MySQL 通过将主节点的 Binlog 同步给节点完成主从之间的数据同步。

MySQL 的主从集群只会将 binlog 从主节点到从节点，而不会反过来同步。由此也就引申出了读写分离的问题。

**因为要保证主从之间的数据一致，写数据的操作只能在主节点完成。而读数据的操作，可以在主节点或者从节点上完成。**

### MySQL 主从同步原理

Mysql 主从同步的过程：

Mysql 的主从复制中主要有三个线程：`master(binlog dump thread)、slave(I/O thread、SQL thread)`，Master 一条线程和 Slave 中的两条线程。

- 主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务器启动那一刻起，保存所有修改数据库结构或内容的一个文件。
- 主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。
- 从节点 I/O 线程接收 binlog 内容，并将其先入 relay log(中继日志) 文件中。
- 从节点的 SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。

注：主从节点使用 binlog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。

由于 mysql 默认的复制方式是异步的，主库把日志发送给从库后不关系从库是否已经处理，这样产生一个问题就是假设主库挂了，从库处理失败，这时候从库升为主库后，日志就丢失了。由此产生两个概念：

**全同步复制**

主库写入 binlog 后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。

**半同步复制**

和全同步不同的是，半同步赋值的逻辑是这样的，从库写入日志成功后返回 ACK 确认给主库，主库收到至少一个从库的确认就认为写操作完成。

## 👉 运维篇

## 公众号

 ![](https://s1.vika.cn/space/2022/12/01/f1f467dd3b8e4984a50dce782aa346ff)
