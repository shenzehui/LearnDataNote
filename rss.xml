<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://newzone.top/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://newzone.top/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Java达摩院</title>
    <link>https://newzone.top/</link>
    <description>一位来自计算机在校大学生的个人技术博客，其中涵盖了Java基础、Java并发编程、Java虚拟机、精选面试题、数据结构和算法、计算机网络、Spring、SpringCloud等内容，✨初衷是希望能够和大家一起交流和分享所学到的技术</description>
    <language>zh-CN</language>
    <pubDate>Sat, 03 Jun 2023 12:03:24 GMT</pubDate>
    <lastBuildDate>Sat, 03 Jun 2023 12:03:24 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>开源项目</category>
    <category>算法指北</category>
    <category>Netty</category>
    <item>
      <title>技术派开源社区项目</title>
      <link>https://newzone.top/projectlearn/paicoding-learning.html</link>
      <guid>https://newzone.top/projectlearn/paicoding-learning.html</guid>
      <source url="https://newzone.top/rss.xml">技术派开源社区项目</source>
      <description>项目地址：https://github.com/itwanger/paicoding</description>
      <category>开源项目</category>
      <pubDate>Sat, 03 Jun 2023 12:01:26 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>项目地址：<a href="https://github.com/itwanger/paicoding" target="_blank" rel="noopener noreferrer">https://github.com/itwanger/paicoding</a></p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>寻找重复数</title>
      <link>https://newzone.top/algorithm/binary_search/findDuplicatedNumber.html</link>
      <guid>https://newzone.top/algorithm/binary_search/findDuplicatedNumber.html</guid>
      <source url="https://newzone.top/rss.xml">寻找重复数</source>
      <description>力扣链接：https://leetcode.cn/problems/search-a-2d-matrix/</description>
      <category>算法指北</category>
      <pubDate>Sat, 03 Jun 2023 12:01:26 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>力扣链接：<a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/search-a-2d-matrix/</a></p>
</blockquote>
<h2> 题目说明</h2>
<p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数，假设只有一个重复的整数，找出这个重复的数。</p>
<h2> 示例</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ul>
<li>不能更改原数组（假设数组是只读的）</li>
<li>只能使用额外的 O(1) 空间</li>
<li>时间复杂度小于 O(n^2)</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ul>
<h2> 分析</h2>
<p>怎样证明 nums 中存在至少一个重复值？其实很简单，这是"抽屉原理"（或者叫"鸽子洞原理"）的简单应用。</p>
<p>这里，nums 中的每个数字（n+1个）都是一个物品，nums 中可以出现的每个不同的数字（n个）都是一个"抽屉"。把 n+1 个物品放入 n 个抽屉中，必然至少会有一个抽屉放了 2 个或者 2 个以上的物品。所以这意味着 nums 中至少有一个数是重复的。</p>
<h2> 题解</h2>
]]></content:encoded>
    </item>
    <item>
      <title>二分查找</title>
      <link>https://newzone.top/algorithm/binary_search/</link>
      <guid>https://newzone.top/algorithm/binary_search/</guid>
      <source url="https://newzone.top/rss.xml">二分查找</source>
      <description>起步</description>
      <category>算法指北</category>
      <pubDate>Sat, 27 May 2023 08:26:47 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 起步</h2>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法，前提是数据结构必须先<strong>排好序</strong>，可以在<strong>对数</strong>时间复杂度内完成查找。</p>
<p>二分查找事实上采用的就是一种<strong>分治策略</strong>，它充分利用了元素间的次序关系，可在最坏的情况下用O(log n)完成搜索任务。</p>
<p>它的基本思想是：假设数组元素呈升序排列，将n个元素分成个数大致相同的两半，取 a[n/2] 与欲查找的 x 作比较，如果 x=a[n/2] 则找到 x，算法终止；如果 x&lt;a[n/2]，则我们只要在数组 a 的左半部继续搜索 x；如果 x&gt;a[n/2]，则我们只要在数组 a 的右半部继续搜索 x。</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527155648073.png" alt="image-20230527155648073" loading="lazy"></p>
<p>二分查找问题也是面试中经常考到的问题，虽然它的思想很简单，但写好二分查找算法并不是一件容易的事情。</p>
<h2> 实现</h2>
<p>接下来，我们首先用代码实现一个 int 数组的二分查找：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，我们也可以用递归的方式实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527160231252.png" alt="image-20230527160231252" loading="lazy"></p>
<h2> 最后</h2>
<p>我们总结一下二分查找：</p>
<ul>
<li>
<p>优点是比较次数少，查找速度快，平均性能好；</p>
</li>
<li>
<p>缺点是要求待查表为有序表，且插入删除困难。</p>
</li>
</ul>
<p>因此，二分查找方法适用于不经常变动而查找频繁的有序列表。使用条件：查找序列是顺序结构，有序。</p>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527155648073.png" type="image/png"/>
    </item>
    <item>
      <title>搜索二维矩阵</title>
      <link>https://newzone.top/algorithm/binary_search/searchMatrix.html</link>
      <guid>https://newzone.top/algorithm/binary_search/searchMatrix.html</guid>
      <source url="https://newzone.top/rss.xml">搜索二维矩阵</source>
      <description>力扣链接：https://leetcode.cn/problems/search-a-2d-matrix/</description>
      <category>算法指北</category>
      <pubDate>Sat, 27 May 2023 08:25:52 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>力扣链接：<a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/search-a-2d-matrix/</a></p>
</blockquote>
<h2> 题目说明</h2>
<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排序。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<h2> 示例</h2>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527160630891.png" alt="image-20230527160630891" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>提示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 分析</h2>
<p>既然这是一个查找元素的问题，并且数组已经排好序，我们自然可以想到利用二分查找是一个高效的方式。</p>
<p>输入的 m x n 矩阵可以视为长度为 m x n 的有序数组：</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527160918019.png" alt="image-20230527160918019" loading="lazy"></p>
<p>行列坐标为（row，col)的元素，展开之后索引下标为 <strong>idx = row * n + col</strong>；反过来，对于一维坐标为 idx 的元素，对应二维数组中的坐标就是：<strong>row = idx/n；col = idx % n;</strong></p>
<h2> 题解</h2>
<h3> 使用二分查找</h3>
<p>代码实现如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更加优雅的实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 最后</h2>
<p><strong>复杂度分析</strong></p>
<ul>
<li>
<p>时间复杂度 : 由于是标准的二分查找，时间复杂度为 O(log(m n))。</p>
</li>
<li>
<p>空间复杂度 : 没有用到额外的空间，复杂度为 O(1)。</p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527160630891.png" type="image/png"/>
    </item>
    <item>
      <title>下一个排列</title>
      <link>https://newzone.top/algorithm/array/nextPermutation.html</link>
      <guid>https://newzone.top/algorithm/array/nextPermutation.html</guid>
      <source url="https://newzone.top/rss.xml">下一个排列</source>
      <description>力扣链接：https://leetcode.cn/problems/next-permutation/</description>
      <category>算法指北</category>
      <pubDate>Sat, 27 May 2023 07:47:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>力扣链接：<a href="https://leetcode.cn/problems/next-permutation/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/next-permutation/</a></p>
</blockquote>
<h2> 题目说明</h2>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排序成字典序列中下一个更大的排序。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须原地修改，只允许有额外常数空间。</p>
<h2> 示例</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 题解</h2>
<h3> 方法一：暴力法</h3>
<p>最简单的想法就是暴力枚举，我们找到由给定数组的元素形成的列表的每个可能的排序，并找出给定的排列更大的排列。</p>
<p>但是这个方法要求我们找出所有可能的排列，这需要很长时间，实施起来也很复杂。因此，这种算法不能满足要求。 我们跳过它的实现，直接采用正确的方法。</p>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n!)，可能的排列总计有 n! 个。</p>
<p>空间复杂度：O(n)，因为数组将用于存储排列。</p>
<h3> 方法二：一遍扫描</h3>
<p>首先，我们观察到对于任何给定序列的<strong>降序排序</strong>，就不会有下一个更大的排列。</p>
<p>例如，以下数组不可能有下一个排列：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这时应该直接返回升序排列。</p>
<p>所以对于一般的情况，如果有一个"升序子序列"，那么就一定可以找到它的下一个排列。具体来说，需要从右边找到第一对连续的数组 a[i] 和 a[i-1]，它们满足 a[i] &gt; a[i-1]。</p>
<p>所以一个思路是，找到最后一个的"正序"排列的子序列，把它改成下一个排列就行了。</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527145642719.png" alt="image-20230527145642719" loading="lazy"></p>
<p>不过具体操作会发现，如果正序子序列后没数了，那么子序列的"下一个"一定就是整个序列的"下一个"，这样做没问题，但如果后面还有逆序排列的数，这样就不对了。比如：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最后的正序列子序列是[1,3,8]，但显然不能直接换成[1,8,3]就完事了。而是应该把 3 换成后面比 3 大比 8 小的数，而且选最小的那个 6。接下来，还要让 6 之后的所有数，做一个升序排列，得到结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>代码实现如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 最后</h2>
<p><strong>复杂度分析</strong></p>
<ul>
<li>
<p>时间复杂度：O(N)，其中 NN 为给定序列的长度。我们至多只需要扫描两次序列，以及进行一次反转操作。</p>
</li>
<li>
<p>空间复杂度：O(1)，只需要常数的空间存放若干变量。</p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527145642719.png" type="image/png"/>
    </item>
    <item>
      <title>旋转图像</title>
      <link>https://newzone.top/algorithm/array/rotateImage.html</link>
      <guid>https://newzone.top/algorithm/array/rotateImage.html</guid>
      <source url="https://newzone.top/rss.xml">旋转图像</source>
      <description>力扣链接：https://leetcode.cn/problems/ratate-image/</description>
      <category>算法指北</category>
      <pubDate>Sat, 27 May 2023 07:47:24 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>力扣链接：<a href="https://leetcode.cn/problems/ratate-image/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/ratate-image/</a></p>
</blockquote>
<h2> 题目说明</h2>
<p>给定一个 n X n 的二维矩阵表示一个图像</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<h2> 示例</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 分析</h2>
<p>旋转图像，这个应用在图片处理的过程中，非常常见。我们知道对于计算机而言，图像，其实就是一组像素点的集合（所谓点阵），所以图像旋转的问题，本质上就是一个二维数组的旋转问题。</p>
<h2> 题解</h2>
<h3> 方法一：数学方法（转置再翻转）</h3>
<p>我们可以利用矩阵的特性。所谓顺时针旋转，其实就是<strong>先转置矩阵，然后翻转每一行</strong>。</p>
<p>代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复杂度分析</p>
<ul>
<li>时间复杂度：O(N^2)</li>
</ul>
<p>这个简单的方法已经能达到最优的时间复杂度O(N<sup>2)，因为既然是旋转，那么每个点都应该遍历到，N</sup>2 的复杂度是不可避免的。</p>
<ul>
<li>空间复杂度：O(1)</li>
</ul>
<p>旋转操作是原地完成的，只耗费常数空间。</p>
<h3> 方法二：分治（分为四部分旋转）</h3>
<p>方法 1 使用了两次矩阵操作，能不能只使用一次操作的方法完成旋转呢？</p>
<p>为了实现这一点，我们来研究每个元素在旋转的过程中如何移动。</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527151926538.png" alt="image-20230527151926538" loading="lazy"></p>
<p>这提供给我们了一个思路，可以将给定的矩阵分为四个矩形并且将原地问题划归为旋转这些矩形的问题，这其实就是分治思想。</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527152100227.png" alt="image-20230527152100227" loading="lazy"></p>
<p>具体解法也很直接，可以在每一个矩形中遍历元素，并且长度为 4 的临时列表中移动它们。</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527152459027.png" alt="image-20230527152459027" loading="lazy"></p>
<p>代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>测试：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527153844704.png" alt="image-20230527153844704" loading="lazy"></p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527154302958.png" alt="image-20230527154302958" loading="lazy"></p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527154346658.png" alt="image-20230527154346658" loading="lazy"></p>
<h3> 方法三：改进方法二</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 最后</h2>
<p><strong>复杂度分析</strong></p>
<ul>
<li>
<p>时间复杂度：O(N^2) 是两重循环的复杂度。</p>
</li>
<li>
<p>空间复杂度：O(1) 由于我们在一次循环中的操作是"就地"完成的，并且我们只用了长度为 4 的临时列表做辅助。</p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/image-20230527151926538.png" type="image/png"/>
    </item>
    <item>
      <title>第一章 Netty 介绍和应用场景</title>
      <link>https://newzone.top/netty/chapter01.html</link>
      <guid>https://newzone.top/netty/chapter01.html</guid>
      <source url="https://newzone.top/rss.xml">第一章 Netty 介绍和应用场景</source>
      <description>1.1 Netty 的介绍</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1.1 Netty 的介绍</h2>
<ol>
<li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li>
<li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li>
<li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li>
<li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li>
<li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li>
</ol>
<h2> 1.2 Netty 的应用场景</h2>
<h3> 1.2.1 互联网行业</h3>
<ol>
<li>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</li>
<li>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_01.png" alt="" loading="lazy"></p>
<h3> 1.2.2 游戏行业</h3>
<ol>
<li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li>
<li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li>
<li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_02.png" alt="" loading="lazy"> <img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_03.png" alt="" loading="lazy"></p>
<h3> 1.2.3 大数据领域</h3>
<ol>
<li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li>
<li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_04.png" alt="" loading="lazy"></p>
<h3> 1.2.4 其它开源项目使用到 Netty</h3>
<p>网址：<a href="https://netty.io/wiki/related-projects.html" target="_blank" rel="noopener noreferrer">https://netty.io/wiki/related-projects.html</a></p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_05.png" alt="" loading="lazy"></p>
<h2> 1.4 Netty 的学习资料参考</h2>
<p><a href="https://item.jd.com/12070975.html" target="_blank" rel="noopener noreferrer"><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/59141c1dN7a93c127.jpg" alt="" loading="lazy"></a> <a href="https://item.jd.com/11681556.html" target="_blank" rel="noopener noreferrer"><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/555080b2Ne6cbf9e3.jpg" alt="" loading="lazy"></a></p>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_01.png" type="image/png"/>
    </item>
    <item>
      <title>第二章 Java BIO 编程</title>
      <link>https://newzone.top/netty/chapter02.html</link>
      <guid>https://newzone.top/netty/chapter02.html</guid>
      <source url="https://newzone.top/rss.xml">第二章 Java BIO 编程</source>
      <description>2.1 I/O 模型</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 2.1 I/O 模型</h2>
<h3> 2.1.1 模型基本说明</h3>
<ol>
<li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li>
<li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li>
<li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter02_01.png" alt="" loading="lazy"></p>
<ol start="4">
<li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter02_02.png" alt="" loading="lazy"></p>
<ol start="5">
<li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li>
<li>我们依次展开讲解。</li>
</ol>
<h2> 2.2 BIO、NIO、AIO 使用场景分析</h2>
<ol>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li>
<li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li>
<li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li>
</ol>
<h2> 2.3 Java BIO 基本介绍</h2>
<ol>
<li><code>Java BIO</code> 就是传统的 <code>Java I/O</code> 编程，其相关的类和接口在 <code>java.io</code>。</li>
<li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】</li>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，程序简单易理解。</li>
</ol>
<h2> 2.4 Java BIO 工作机制</h2>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter02_03.png" alt="" loading="lazy"></p>
<p>对 <code>BIO</code> 编程流程的梳理</p>
<ol>
<li>服务器端启动一个 <code>ServerSocket</code>。</li>
<li>客户端启动 <code>Socket</code> 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，在继续执行。</li>
</ol>
<h2> 2.5 Java BIO 应用实例</h2>
<p>实例说明：</p>
<ol>
<li>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</li>
<li>要求使用线程池机制改善，可以连接多个客户端。</li>
<li>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</li>
<li>代码演示：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2.6 Java BIO 问题分析</h2>
<ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li>
</ol>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter02_01.png" type="image/png"/>
    </item>
    <item>
      <title>第三章 Java NIO 编程</title>
      <link>https://newzone.top/netty/chapter03.html</link>
      <guid>https://newzone.top/netty/chapter03.html</guid>
      <source url="https://newzone.top/rss.xml">第三章 Java NIO 编程</source>
      <description>3.1 Java NIO 基本介绍</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 3.1 Java NIO 基本介绍</h2>
<ol>
<li><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong> ，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li>
<li><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li>
<li><code>NIO</code> 有三大核心部分: <strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</li>
<li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li>
<li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li>
<li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li>
<li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li>
<li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.2 NIO 和 BIO 的比较</h2>
<ol>
<li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li>
<li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li>
<li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li>
</ol>
<h2> 3.3 NIO 三大核心原理示意图</h2>
<p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p>
<h3> 3.3.1 Selector、Channel 和 Buffer 关系图（简单版）</h3>
<p>关系图的说明:</p>
<!-- ![](../_media/chapter03/chapter03_01.png)) -->
<img style="height:600px" src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_01.png">
<ol>
<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>
<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>
<li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li>
<li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li>
<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>
<li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li>
<li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>
</ol>
<h2> 3.4 缓冲区（Buffer）</h2>
<h3> 3.4.1 基本介绍</h3>
<p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_02.png" alt="" loading="lazy"></p>
<h3> 3.4.2 Buffer 类及其子类</h3>
<ol>
<li>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_03.png" alt="" loading="lazy"></p>
<ol start="2">
<li><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_05.png" alt="" loading="lazy"></p>
<ol start="3">
<li><code>Buffer</code> 类相关方法一览</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_06.png" alt="" loading="lazy"></p>
<h3> 3.4.3 ByteBuffer</h3>
<p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_07.png" alt="" loading="lazy"></p>
<h2> 3.5 通道（Channel）</h2>
<h2> 3.6 基本介绍</h2>
<ol>
<li><code>NIO</code> 的通道类似于流，但有些区别如下：
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
</li>
<li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li>
<li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable{}</code></li>
<li>常用的 <code>Channel</code> 类有: <strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong> 。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li>
<li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li>
<li>图示</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_08.png" alt="" loading="lazy"></p>
<h3> 3.6.1 FileChannel 类</h3>
<p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p>
<ul>
<li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li>
<li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li>
<li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li>
<li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li>
</ul>
<h3> 3.6.2 应用实例1 - 本地文件写数据</h3>
<p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 "hello,尚硅谷" 写入到 <code>file01.txt</code> 中</li>
<li>文件不存在就创建</li>
<li>代码演示</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.6.3 应用实例2 - 本地文件读数据</h3>
<p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li>
<li>假定文件已经存在</li>
<li>代码演示</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.6.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入</h3>
<p>实例要求：</p>
<ol>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li>
<li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li>
<li>代码演示</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_09.png" alt="" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.6.5 应用实例4 - 拷贝文件 transferFrom 方法</h3>
<ol>
<li>实例要求：</li>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li>
<li>拷贝一张图片</li>
<li>代码演示</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.6.6 关于 Buffer 和 Channel 的注意事项和细节</h3>
<ol>
<li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.7 Selector（选择器）</h2>
<h3> 3.7.1 基本介绍</h3>
<ol>
<li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li>
<li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li>
<li>避免了多线程之间的上下文切换导致的开销。</li>
</ol>
<h3> 3.7.2 Selector 示意图和特点说明</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_10.png" alt="" loading="lazy"></p>
<p>说明如下：</p>
<ol>
<li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li>
<li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li>
<li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li>
<li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li>
<li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>
</ol>
<h3> 3.7.3 Selector 类相关方法</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_11.png" alt="" loading="lazy"></p>
<h3> 3.7.4 注意事项</h3>
<ol>
<li><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</li>
<li><code>Selector</code> 相关方法说明
<ul>
<li><code>selector.select();</code> //阻塞</li>
<li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li><code>selector.wakeup();</code> //唤醒 selector</li>
<li><code>selector.selectNow();</code> //不阻塞，立马返还</li>
</ul>
</li>
</ol>
<h2> 3.8 NIO 非阻塞网络编程原理分析图</h2>
<p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_22.png" alt="" loading="lazy"></p>
<p>对上图的说明：</p>
<ol>
<li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li>
<li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li>
<li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li>
<li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li>
<li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li>
<li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li>
<li>可以通过得到的 <code>channel</code>，完成业务处理。</li>
<li>代码撑腰。。。</li>
</ol>
<h2> 3.9 NIO 非阻塞网络编程快速入门</h2>
<p>案例要求：</p>
<ol>
<li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li>
<li>看老师代码演示</li>
</ol>
<h2> 3.10 SelectionKey</h2>
<ol>
<li><code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种：
<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li>
<li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li>
<li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li>
</ul>
</li>
</ol>
<p>源码中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li><code>SelectionKey</code> 相关方法</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_12.png" alt="" loading="lazy"></p>
<h2> 3.11 ServerSocketChannel</h2>
<ol>
<li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li>
<li>相关方法如下</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_13.png" alt="" loading="lazy"></p>
<h2> 3.12 SocketChannel</h2>
<ol>
<li><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li>
<li>相关方法如下</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_14.png" alt="" loading="lazy"></p>
<h2> 3.13 NIO 网络编程应用实例 - 群聊系统</h2>
<p>实例要求：</p>
<ol>
<li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li>
<li>示意图分析和代码</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_15.png" alt="" loading="lazy"></p>
<p>代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.14 NIO 与零拷贝</h2>
<h3> 3.14.1 零拷贝基本介绍</h3>
<ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开。</li>
<li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li>
<li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li>
</ol>
<h3> 3.14.2 传统 IO 数据读写</h3>
<p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.14.3 传统 IO 模型</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_17.png" alt="" loading="lazy"></p>
<p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p>
<h3> 3.14.4 mmap 优化</h3>
<ol>
<li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li>
<li><code>mmap</code> 示意图</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_18.png" alt="" loading="lazy"></p>
<h3> 3.14.5 sendFile 优化</h3>
<ol>
<li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li>
<li>示意图和小结</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_19.png" alt="" loading="lazy"></p>
<ol start="3">
<li>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</li>
<li><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_20.png" alt="" loading="lazy"></p>
<ol start="5">
<li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li>
</ol>
<h3> 3.14.6 零拷贝的再次理解</h3>
<ol>
<li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li>
</ol>
<h3> 3.14.7 mmap 和 sendFile 的区别</h3>
<ol>
<li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li>
<li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li>
<li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li>
</ol>
<h3> 3.14.8 NIO 零拷贝案例</h3>
<p>案例要求：</p>
<ol>
<li>使用传统的 <code>IO</code> 方法传递一个大文件</li>
<li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.15 Java AIO 基本介绍</h2>
<ol>
<li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
<li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html" target="_blank" rel="noopener noreferrer">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li>
</ol>
<h2> 3.16 BIO、NIO、AIO 对比表</h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">BIO</th>
<th style="text-align:center">NIO</th>
<th style="text-align:center">AIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IO模型</td>
<td style="text-align:center">同步阻塞</td>
<td style="text-align:center">同步非阻塞（多路复用）</td>
<td style="text-align:center">异步非阻塞</td>
</tr>
<tr>
<td style="text-align:center">编程难度</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">复杂</td>
<td style="text-align:center">复杂</td>
</tr>
<tr>
<td style="text-align:center">可靠性</td>
<td style="text-align:center">差</td>
<td style="text-align:center">好</td>
<td style="text-align:center">好</td>
</tr>
<tr>
<td style="text-align:center">吞吐量</td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
<td style="text-align:center">高</td>
</tr>
</tbody>
</table>
<p><strong>举例说明</strong></p>
<ol>
<li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li>
<li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li>
<li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>第四章 Netty 概述</title>
      <link>https://newzone.top/netty/chapter04.html</link>
      <guid>https://newzone.top/netty/chapter04.html</guid>
      <source url="https://newzone.top/rss.xml">第四章 Netty 概述</source>
      <description>4.1 原生 NIO 存在的问题</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 4.1 原生 NIO 存在的问题</h2>
<ol>
<li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li>
<li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。4. <code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li>
</ol>
<h2> 4.2 Netty 官网说明</h2>
<p>官网：<a href="https://netty.io/" target="_blank" rel="noopener noreferrer">https://netty.io/</a></p>
<p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter04_01.png" alt="" loading="lazy"></p>
<h2> 4.3 Netty 的优点</h2>
<p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p>
<ol>
<li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li>
<li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li>
<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li>
</ol>
<h2> 4.4 Netty 版本说明</h2>
<ol>
<li><code>Netty</code> 版本分为 <code>Netty 3.x</code> 和 <code>Netty 4.x</code>、<code>Netty 5.x</code></li>
<li>因为 <code>Netty 5</code> 出现重大 <code>bug</code>，已经被官网废弃了，目前推荐使用的是 <code>Netty 4.x</code>的稳定版本</li>
<li>目前在官网可下载的版本 <code>Netty 3.x</code>、<code>Netty 4.0.x</code> 和 <code>Netty 4.1.x</code></li>
<li>在本套课程中，我们讲解 <code>Netty4.1.x</code> 版本</li>
<li><code>Netty</code> 下载地址：<a href="https://bintray.com/netty/downloads/netty/" target="_blank" rel="noopener noreferrer">https://bintray.com/netty/downloads/netty/</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter04_01.png" type="image/png"/>
    </item>
  </channel>
</rss>