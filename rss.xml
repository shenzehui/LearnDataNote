<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://newzone.top/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://newzone.top/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Java达摩院</title>
    <link>https://newzone.top/</link>
    <description>一位来自计算机在校大学生的个人技术博客，其中涵盖了Java基础、Java并发编程、Java虚拟机、精选面试题、数据结构和算法、计算机网络、Spring、SpringCloud等内容，✨初衷是希望能够和大家一起交流和分享所学到的技术</description>
    <language>zh-CN</language>
    <pubDate>Fri, 26 May 2023 11:08:24 GMT</pubDate>
    <lastBuildDate>Fri, 26 May 2023 11:08:24 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>Netty</category>
    <item>
      <title>第一章 Netty 介绍和应用场景</title>
      <link>https://newzone.top/netty/chapter01.html</link>
      <guid>https://newzone.top/netty/chapter01.html</guid>
      <source url="https://newzone.top/rss.xml">第一章 Netty 介绍和应用场景</source>
      <description>1.1 Netty 的介绍</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1.1 Netty 的介绍</h2>
<ol>
<li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li>
<li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li>
<li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li>
<li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li>
<li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li>
</ol>
<h2> 1.2 Netty 的应用场景</h2>
<h3> 1.2.1 互联网行业</h3>
<ol>
<li>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</li>
<li>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_01.png" alt="" loading="lazy"></p>
<h3> 1.2.2 游戏行业</h3>
<ol>
<li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li>
<li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li>
<li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_02.png" alt="" loading="lazy"> <img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_03.png" alt="" loading="lazy"></p>
<h3> 1.2.3 大数据领域</h3>
<ol>
<li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li>
<li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_04.png" alt="" loading="lazy"></p>
<h3> 1.2.4 其它开源项目使用到 Netty</h3>
<p>网址：<a href="https://netty.io/wiki/related-projects.html" target="_blank" rel="noopener noreferrer">https://netty.io/wiki/related-projects.html</a></p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_05.png" alt="" loading="lazy"></p>
<h2> 1.4 Netty 的学习资料参考</h2>
<p><a href="https://item.jd.com/12070975.html" target="_blank" rel="noopener noreferrer"><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/59141c1dN7a93c127.jpg" alt="" loading="lazy"></a> <a href="https://item.jd.com/11681556.html" target="_blank" rel="noopener noreferrer"><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/555080b2Ne6cbf9e3.jpg" alt="" loading="lazy"></a></p>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter01_01.png" type="image/png"/>
    </item>
    <item>
      <title>第二章 Java BIO 编程</title>
      <link>https://newzone.top/netty/chapter02.html</link>
      <guid>https://newzone.top/netty/chapter02.html</guid>
      <source url="https://newzone.top/rss.xml">第二章 Java BIO 编程</source>
      <description>2.1 I/O 模型</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 2.1 I/O 模型</h2>
<h3> 2.1.1 模型基本说明</h3>
<ol>
<li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li>
<li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li>
<li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter02_01.png" alt="" loading="lazy"></p>
<ol start="4">
<li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter02_02.png" alt="" loading="lazy"></p>
<ol start="5">
<li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li>
<li>我们依次展开讲解。</li>
</ol>
<h2> 2.2 BIO、NIO、AIO 使用场景分析</h2>
<ol>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li>
<li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li>
<li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li>
</ol>
<h2> 2.3 Java BIO 基本介绍</h2>
<ol>
<li><code>Java BIO</code> 就是传统的 <code>Java I/O</code> 编程，其相关的类和接口在 <code>java.io</code>。</li>
<li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】</li>
<li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，程序简单易理解。</li>
</ol>
<h2> 2.4 Java BIO 工作机制</h2>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter02_03.png" alt="" loading="lazy"></p>
<p>对 <code>BIO</code> 编程流程的梳理</p>
<ol>
<li>服务器端启动一个 <code>ServerSocket</code>。</li>
<li>客户端启动 <code>Socket</code> 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li>
<li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li>
<li>如果有响应，客户端线程会等待请求结束后，在继续执行。</li>
</ol>
<h2> 2.5 Java BIO 应用实例</h2>
<p>实例说明：</p>
<ol>
<li>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</li>
<li>要求使用线程池机制改善，可以连接多个客户端。</li>
<li>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</li>
<li>代码演示：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2.6 Java BIO 问题分析</h2>
<ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li>
</ol>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter02_01.png" type="image/png"/>
    </item>
    <item>
      <title>第三章 Java NIO 编程</title>
      <link>https://newzone.top/netty/chapter03.html</link>
      <guid>https://newzone.top/netty/chapter03.html</guid>
      <source url="https://newzone.top/rss.xml">第三章 Java NIO 编程</source>
      <description>3.1 Java NIO 基本介绍</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 3.1 Java NIO 基本介绍</h2>
<ol>
<li><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong> ，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li>
<li><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li>
<li><code>NIO</code> 有三大核心部分: <strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</li>
<li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li>
<li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li>
<li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li>
<li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li>
<li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.2 NIO 和 BIO 的比较</h2>
<ol>
<li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li>
<li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li>
<li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li>
</ol>
<h2> 3.3 NIO 三大核心原理示意图</h2>
<p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p>
<h3> 3.3.1 Selector、Channel 和 Buffer 关系图（简单版）</h3>
<p>关系图的说明:</p>
<!-- ![](../_media/chapter03/chapter03_01.png)) -->
<img style="height:600px" src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_01.png">
<ol>
<li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li>
<li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li>
<li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li>
<li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li>
<li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li>
<li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li>
<li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li>
</ol>
<h2> 3.4 缓冲区（Buffer）</h2>
<h3> 3.4.1 基本介绍</h3>
<p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_02.png" alt="" loading="lazy"></p>
<h3> 3.4.2 Buffer 类及其子类</h3>
<ol>
<li>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_03.png" alt="" loading="lazy"></p>
<ol start="2">
<li><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_05.png" alt="" loading="lazy"></p>
<ol start="3">
<li><code>Buffer</code> 类相关方法一览</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_06.png" alt="" loading="lazy"></p>
<h3> 3.4.3 ByteBuffer</h3>
<p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_07.png" alt="" loading="lazy"></p>
<h2> 3.5 通道（Channel）</h2>
<h2> 3.6 基本介绍</h2>
<ol>
<li><code>NIO</code> 的通道类似于流，但有些区别如下：
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲:</li>
</ul>
</li>
<li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li>
<li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable{}</code></li>
<li>常用的 <code>Channel</code> 类有: <strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong> 。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li>
<li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li>
<li>图示</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_08.png" alt="" loading="lazy"></p>
<h3> 3.6.1 FileChannel 类</h3>
<p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p>
<ul>
<li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li>
<li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li>
<li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li>
<li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li>
</ul>
<h3> 3.6.2 应用实例1 - 本地文件写数据</h3>
<p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 "hello,尚硅谷" 写入到 <code>file01.txt</code> 中</li>
<li>文件不存在就创建</li>
<li>代码演示</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.6.3 应用实例2 - 本地文件读数据</h3>
<p>实例要求：</p>
<ol>
<li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li>
<li>假定文件已经存在</li>
<li>代码演示</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.6.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入</h3>
<p>实例要求：</p>
<ol>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li>
<li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li>
<li>代码演示</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_09.png" alt="" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.6.5 应用实例4 - 拷贝文件 transferFrom 方法</h3>
<ol>
<li>实例要求：</li>
<li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li>
<li>拷贝一张图片</li>
<li>代码演示</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.6.6 关于 Buffer 和 Channel 的注意事项和细节</h3>
<ol>
<li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.7 Selector（选择器）</h2>
<h3> 3.7.1 基本介绍</h3>
<ol>
<li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li>
<li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li>
<li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li>
<li>避免了多线程之间的上下文切换导致的开销。</li>
</ol>
<h3> 3.7.2 Selector 示意图和特点说明</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_10.png" alt="" loading="lazy"></p>
<p>说明如下：</p>
<ol>
<li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li>
<li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li>
<li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li>
<li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li>
<li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li>
</ol>
<h3> 3.7.3 Selector 类相关方法</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_11.png" alt="" loading="lazy"></p>
<h3> 3.7.4 注意事项</h3>
<ol>
<li><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</li>
<li><code>Selector</code> 相关方法说明
<ul>
<li><code>selector.select();</code> //阻塞</li>
<li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li>
<li><code>selector.wakeup();</code> //唤醒 selector</li>
<li><code>selector.selectNow();</code> //不阻塞，立马返还</li>
</ul>
</li>
</ol>
<h2> 3.8 NIO 非阻塞网络编程原理分析图</h2>
<p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_22.png" alt="" loading="lazy"></p>
<p>对上图的说明：</p>
<ol>
<li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li>
<li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li>
<li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li>
<li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li>
<li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li>
<li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li>
<li>可以通过得到的 <code>channel</code>，完成业务处理。</li>
<li>代码撑腰。。。</li>
</ol>
<h2> 3.9 NIO 非阻塞网络编程快速入门</h2>
<p>案例要求：</p>
<ol>
<li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li>
<li>看老师代码演示</li>
</ol>
<h2> 3.10 SelectionKey</h2>
<ol>
<li><code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种：
<ul>
<li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li>
<li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li>
<li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li>
<li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li>
</ul>
</li>
</ol>
<p>源码中：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li><code>SelectionKey</code> 相关方法</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_12.png" alt="" loading="lazy"></p>
<h2> 3.11 ServerSocketChannel</h2>
<ol>
<li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li>
<li>相关方法如下</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_13.png" alt="" loading="lazy"></p>
<h2> 3.12 SocketChannel</h2>
<ol>
<li><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li>
<li>相关方法如下</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_14.png" alt="" loading="lazy"></p>
<h2> 3.13 NIO 网络编程应用实例 - 群聊系统</h2>
<p>实例要求：</p>
<ol>
<li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li>
<li>示意图分析和代码</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_15.png" alt="" loading="lazy"></p>
<p>代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.14 NIO 与零拷贝</h2>
<h3> 3.14.1 零拷贝基本介绍</h3>
<ol>
<li>零拷贝是网络编程的关键，很多性能优化都离不开。</li>
<li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li>
<li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li>
</ol>
<h3> 3.14.2 传统 IO 数据读写</h3>
<p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.14.3 传统 IO 模型</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_17.png" alt="" loading="lazy"></p>
<p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p>
<h3> 3.14.4 mmap 优化</h3>
<ol>
<li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li>
<li><code>mmap</code> 示意图</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_18.png" alt="" loading="lazy"></p>
<h3> 3.14.5 sendFile 优化</h3>
<ol>
<li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li>
<li>示意图和小结</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_19.png" alt="" loading="lazy"></p>
<ol start="3">
<li>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</li>
<li><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter03_20.png" alt="" loading="lazy"></p>
<ol start="5">
<li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li>
</ol>
<h3> 3.14.6 零拷贝的再次理解</h3>
<ol>
<li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li>
<li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li>
</ol>
<h3> 3.14.7 mmap 和 sendFile 的区别</h3>
<ol>
<li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li>
<li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li>
<li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li>
</ol>
<h3> 3.14.8 NIO 零拷贝案例</h3>
<p>案例要求：</p>
<ol>
<li>使用传统的 <code>IO</code> 方法传递一个大文件</li>
<li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li>
<li>看看两种传递方式耗时时间分别是多少</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.15 Java AIO 基本介绍</h2>
<ol>
<li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li>
<li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li>
<li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html" target="_blank" rel="noopener noreferrer">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li>
</ol>
<h2> 3.16 BIO、NIO、AIO 对比表</h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">BIO</th>
<th style="text-align:center">NIO</th>
<th style="text-align:center">AIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IO模型</td>
<td style="text-align:center">同步阻塞</td>
<td style="text-align:center">同步非阻塞（多路复用）</td>
<td style="text-align:center">异步非阻塞</td>
</tr>
<tr>
<td style="text-align:center">编程难度</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">复杂</td>
<td style="text-align:center">复杂</td>
</tr>
<tr>
<td style="text-align:center">可靠性</td>
<td style="text-align:center">差</td>
<td style="text-align:center">好</td>
<td style="text-align:center">好</td>
</tr>
<tr>
<td style="text-align:center">吞吐量</td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
<td style="text-align:center">高</td>
</tr>
</tbody>
</table>
<p><strong>举例说明</strong></p>
<ol>
<li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li>
<li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li>
<li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>第四章 Netty 概述</title>
      <link>https://newzone.top/netty/chapter04.html</link>
      <guid>https://newzone.top/netty/chapter04.html</guid>
      <source url="https://newzone.top/rss.xml">第四章 Netty 概述</source>
      <description>4.1 原生 NIO 存在的问题</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 4.1 原生 NIO 存在的问题</h2>
<ol>
<li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li>
<li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li>
<li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。4. <code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li>
</ol>
<h2> 4.2 Netty 官网说明</h2>
<p>官网：<a href="https://netty.io/" target="_blank" rel="noopener noreferrer">https://netty.io/</a></p>
<p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter04_01.png" alt="" loading="lazy"></p>
<h2> 4.3 Netty 的优点</h2>
<p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p>
<ol>
<li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li>
<li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li>
<li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li>
<li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li>
<li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li>
</ol>
<h2> 4.4 Netty 版本说明</h2>
<ol>
<li><code>Netty</code> 版本分为 <code>Netty 3.x</code> 和 <code>Netty 4.x</code>、<code>Netty 5.x</code></li>
<li>因为 <code>Netty 5</code> 出现重大 <code>bug</code>，已经被官网废弃了，目前推荐使用的是 <code>Netty 4.x</code>的稳定版本</li>
<li>目前在官网可下载的版本 <code>Netty 3.x</code>、<code>Netty 4.0.x</code> 和 <code>Netty 4.1.x</code></li>
<li>在本套课程中，我们讲解 <code>Netty4.1.x</code> 版本</li>
<li><code>Netty</code> 下载地址：<a href="https://bintray.com/netty/downloads/netty/" target="_blank" rel="noopener noreferrer">https://bintray.com/netty/downloads/netty/</a></li>
</ol>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter04_01.png" type="image/png"/>
    </item>
    <item>
      <title>第五章 Netty 高性能架构设计</title>
      <link>https://newzone.top/netty/chapter05.html</link>
      <guid>https://newzone.top/netty/chapter05.html</guid>
      <source url="https://newzone.top/rss.xml">第五章 Netty 高性能架构设计</source>
      <description>5.1 线程模型基本介绍</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 5.1 线程模型基本介绍</h2>
<ol>
<li>不同的线程模式，对程序的性能有很大影响，为了搞清 <code>Netty</code> 线程模式，我们来系统的讲解下各个线程模式，最后看看 <code>Netty</code> 线程模型有什么优越性。</li>
<li>目前存在的线程模型有：传统阻塞 <code>I/O</code> 服务模型 <code>Reactor</code> 模式</li>
<li>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现单 <code>Reactor</code> 单线程；单 <code>Reactor</code>多线程；主从 <code>Reactor</code>多线程</li>
<li><code>Netty</code> 线程模式（<code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>）</li>
</ol>
<h2> 5.2 传统阻塞 I/O 服务模型</h2>
<h3> 5.2.1 工作原理图</h3>
<ol>
<li>黄色的框表示对象，蓝色的框表示线程</li>
<li>白色的框表示方法（<code>API</code>）</li>
</ol>
<h3> 5.2.2 模型特点</h3>
<ol>
<li>采用阻塞 <code>IO</code> 模式获取输入的数据</li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li>
</ol>
<h3> 5.2.3 问题分析</h3>
<ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 <code>read</code> 操作，造成线程资源浪费</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_01.png" alt="" loading="lazy"></p>
<h2> 5.3 Reactor 模式</h2>
<h3> 5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</h3>
<ol>
<li>
<p>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理 <code>Reactor</code> 对应的叫法：</p>
<ol>
<li>反应器模式</li>
<li>分发者模式（Dispatcher）</li>
<li>通知者模式（notifier）</li>
</ol>
</li>
<li>
<p>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</p>
</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_02.png" alt="" loading="lazy"></p>
<h3> 5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_03.png" alt="" loading="lazy"></p>
<p>对上图说明：</p>
<ol>
<li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li>
<li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li>
<li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li>
</ol>
<h3> 5.3.3 Reactor 模式中核心组成</h3>
<ol>
<li><code>Reactor</code>：<code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 <code>IO</code> 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li>
<li><code>Handlers</code>：处理程序执行 <code>I/O</code> 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code> 通过调度适当的处理程序来响应 <code>I/O</code> 事件，处理程序执行非阻塞操作。</li>
</ol>
<h3> 5.3.4 Reactor 模式分类</h3>
<p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p>
<ol>
<li>单 <code>Reactor</code> 单线程</li>
<li>单 <code>Reactor</code> 多线程</li>
<li>主从 <code>Reactor</code> 多线程</li>
</ol>
<h2> 5.4 单 Reactor 单线程</h2>
<p>原理图，并使用 <code>NIO</code> 群聊系统验证</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_04.png" alt="" loading="lazy"></p>
<h3> 5.4.1 方案说明</h3>
<ol>
<li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li>
<li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li>
<li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li>
</ol>
<p>结合实例：服务器端用一个线程通过多路复用搞定所有的 <code>IO</code> 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 <code>NIO</code> 案例就属于这种模型。</p>
<h3> 5.4.2 方案优缺点分析</h3>
<ol>
<li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
<li>缺点：性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
<li>使用场景：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code> 在业务处理的时间复杂度 <code>O(1)</code> 的情况</li>
</ol>
<h2> 5.5 单 Reactor 多线程</h2>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_05.png" alt="" loading="lazy"></p>
<h3> 5.5.1 原理图</h3>
<h3> 5.5.2 对上图的小结</h3>
<ol>
<li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li>
<li>如果建立连接请求，则右 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理</li>
<li><code>handler</code> 只负责响应事件，不做具体的业务处理，通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务</li>
<li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li>
<li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li>
</ol>
<h3> 5.5.3 方案优缺点分析</h3>
<ol>
<li>优点：可以充分的利用多核 <code>cpu</code> 的处理能力</li>
<li>缺点：多线程数据共享和访问比较复杂，<code>Reactor</code> 处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li>
</ol>
<h2> 5.6 主从 Reactor 多线程</h2>
<h3> 5.6.1 工作原理图</h3>
<p>针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_06.png" alt="" loading="lazy"></p>
<h3> 5.6.2 上图的方案说明</h3>
<ol>
<li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li>
<li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li>
<li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li>
<li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li>
<li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li>
<li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li>
<li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li>
<li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li>
</ol>
<h3> 5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解：</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_07.png" alt="" loading="lazy"></p>
<h3> 5.6.4 方案优缺点说明</h3>
<ol>
<li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li>优点：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
<li>缺点：编程复杂度较高</li>
<li>结合实例：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li>
</ol>
<h2> 5.7 Reactor 模式小结</h2>
<h3> 5.7.1 3 种模式用生活案例来理解</h3>
<ol>
<li>单 <code>Reactor</code> 单线程，前台接待员和服务员是同一个人，全程为顾客服务</li>
<li>单 <code>Reactor</code> 多线程，<code>1</code> 个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从 <code>Reactor</code> 多线程，多个前台接待员，多个服务生</li>
</ol>
<h3> 5.7.2 Reactor 模式具有如下的优点</h3>
<ol>
<li>响应快，不必为单个同步时间所阻塞，虽然 <code>Reactor</code> 本身依然是同步的</li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
<li>扩展性好，可以方便的通过增加 <code>Reactor</code> 实例个数来充分利用 <code>CPU</code> 资源</li>
<li>复用性好，<code>Reactor</code> 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ol>
<h2> 5.8 Netty 模型</h2>
<h3> 5.8.1 工作原理示意图1 - 简单版</h3>
<p><code>Netty</code> 主要基于主从 <code>Reactors</code> 多线程模型（如图）做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code></p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_08.png" alt="" loading="lazy"></p>
<h3> 5.8.2 对上图说明</h3>
<ol>
<li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li>
<li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li>
<li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li>
</ol>
<h3> 5.8.3 工作原理示意图2 - 进阶版</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_09.png" alt="" loading="lazy"></p>
<h3> 5.8.4 工作原理示意图 - 详细版</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_10.png" alt="" loading="lazy"></p>
<h3> 5.8.5 对上图的说明小结</h3>
<ol>
<li><code>Netty</code> 抽象出两组线程池 <code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</li>
<li><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></li>
<li><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></li>
<li><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</li>
<li><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></li>
<li>每个 <code>BossNioEventLoop</code> 循环执行的步骤有 <code>3</code> 步
<ul>
<li>轮询 <code>accept</code> 事件</li>
<li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>worker</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li>
<li>处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li>每个 <code>Worker</code> <code>NIOEventLoop</code> 循环执行的步骤
<ul>
<li>轮询 <code>read</code>，<code>write</code> 事件</li>
<li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li>
<li>处理任务队列的任务，即 <code>runAllTasks</code></li>
</ul>
</li>
<li>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器</li>
</ol>
<h3> 5.8.6 Netty 快速入门实例 - TCP 服务</h3>
<p>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</p>
<ol>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，客户端能发送消息给服务器"hello,服务器~"</li>
<li>服务器可以回复消息给客户端"hello,客户端~"</li>
<li>目的：对 <code>Netty</code> 线程模型有一个初步认识，便于理解 <code>Netty</code> 模型理论</li>
<li>看老师代码演示
5.1 编写服务端   5.2 编写客户端   5.3 对 <code>netty</code> 程序进行分析，看看 <code>netty</code> 模型特点
说明：创建 <code>Maven</code> 项目，并引入 <code>Netty</code> 包</li>
<li>代码如下</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.8.7 任务队列中的 Task 有 3 种典型使用场景</h3>
<ol>
<li>用户程序自定义的普通任务【举例说明】</li>
<li>用户自定义定时任务</li>
<li>非当前 <code>Reactor</code> 线程调用 <code>Channel</code> 的各种方法
例如在推送系统的业务线程里面，根据用户的标识，找到对应的 <code>Channel</code> 引用，然后调用 <code>Write</code> 类方法向该用户推送消息，就会进入到这种场景。最终的 <code>Write</code> 会提交到任务队列中后被异步消费</li>
<li>代码演示</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.8.8 方案再说明</h3>
<ol>
<li><code>Netty</code> 抽象出两组线程池，<code>BossGroup</code> 专门负责接收客户端连接，<code>WorkerGroup</code> 专门负责网络读写操作。</li>
<li><code>NioEventLoop</code> 表示一个不断循环执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code>网络通道。</li>
<li><code>NioEventLoop</code> 内部采用串行化设计，从消息的 <strong>读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</strong>，始终由 <code>IO</code> 线程 <code>NioEventLoop</code> 负责</li>
</ol>
<p><code>NioEventLoopGroup</code> 下包含多个 <code>NioEventLoop</code></p>
<ul>
<li>每个 <code>NioEventLoop</code> 中包含有一个 <code>Selector</code>，一个 <code>taskQueue</code></li>
<li>每个 <code>NioEventLoop</code> 的 <code>Selector</code> 上可以注册监听多个 <code>NioChannel</code></li>
<li>每个 <code>NioChannel</code> 只会绑定在唯一的 <code>NioEventLoop</code> 上</li>
<li>每个 <code>NioChannel</code> 都绑定有一个自己的 <code>ChannelPipeline</code></li>
</ul>
<h2> 5.9 异步模型</h2>
<h3> 5.9.1 基本介绍</h3>
<ol>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li>
<li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind、Write、Connect</code> 等操作会简单的返回一个 <code>ChannelFuture</code>。</li>
<li>调用者并不能立刻获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机制获得 <code>IO</code> 操作结果。</li>
<li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code> 返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code> 去监控方法 <code>fun</code> 的处理过程（即：<code>Future-Listener</code> 机制）</li>
</ol>
<h3> 5.9.2 Future 说明</h3>
<ol>
<li>表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</li>
<li><code>ChannelFuture</code> 是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code> 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。案例说明</li>
</ol>
<h3> 5.9.3 工作原理示意图</h3>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_11.png" alt="" loading="lazy"></p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_12.png" alt="" loading="lazy"></p>
<p>说明：</p>
<ol>
<li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用 <code>future</code> 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li>
<li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</li>
</ol>
<h3> 5.9.4 Future-Listener 机制</h3>
<ol>
<li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li>
<li>常见有如下操作
<ul>
<li>通过 <code>isDone</code> 方法来判断当前操作是否完成；</li>
<li>通过 <code>isSuccess</code> 方法来判断已完成的当前操作是否成功；</li>
<li>通过 <code>getCause</code> 方法来获取已完成的当前操作失败的原因；</li>
<li>通过 <code>isCancelled</code> 方法来判断已完成的当前操作是否被取消；</li>
<li>通过 <code>addListener</code> 方法来注册监听器，当操作已完成（<code>isDone</code>方法返回完成），将会通知指定的监听器；如果 <code>Future</code> 对象已完成，则通知指定的监听器</li>
</ul>
</li>
</ol>
<p>举例说明
演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5.10 快速入门实例 - HTTP服务</h2>
<ol>
<li>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</li>
<li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，浏览器发出请求 <code>http://localhost:6668/</code></li>
<li>服务器可以回复消息给客户端"Hello!我是服务器5",并对特定请求资源进行过滤。</li>
<li>目的：<code>Netty</code> 可以做 <code>Http</code> 服务开发，并且理解 <code>Handler</code> 实例和客户端及其请求的关系。</li>
<li>看老师代码演示</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter05_01.png" type="image/png"/>
    </item>
    <item>
      <title>第六章 Netty 核心模块组件</title>
      <link>https://newzone.top/netty/chapter06.html</link>
      <guid>https://newzone.top/netty/chapter06.html</guid>
      <source url="https://newzone.top/rss.xml">第六章 Netty 核心模块组件</source>
      <description>6.1 Bootstrap、ServerBootstrap</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 6.1 Bootstrap、ServerBootstrap</h2>
<ol>
<li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li>
<li>常见的方法有
<ul>
<li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li>
<li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li>
<li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li>
<li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li>
<li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li>
<li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li>
<li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li>
<li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li>
</ul>
</li>
</ol>
<h2> 6.2 Future、ChannelFuture</h2>
<p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p>
<p>常见的方法有</p>
<ul>
<li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li>
<li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li>
</ul>
<h2> 6.3 Channel</h2>
<ol>
<li><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</li>
<li>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</li>
<li>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</li>
<li><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</li>
<li>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</li>
<li>支持关联 <code>I/O</code> 操作与对应的处理程序</li>
<li>不同协议、不同的阻塞类型的连接都有不同的 <code>Channel</code> 类型与之对应，常用的 <code>Channel</code> 类型：
<ul>
<li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li>
<li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li>
<li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li>
<li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li>
</ul>
</li>
</ol>
<h2> 6.4 Selector</h2>
<ol>
<li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li>
<li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li>
</ol>
<h2> 6.5 ChannelHandler 及其实现类</h2>
<ol>
<li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li>
<li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li>
<li><code>ChannelHandler</code> 及其实现类一览图（后）</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_01.png" alt="" loading="lazy"></p>
<ol start="4">
<li>我们经常需要自定义一个 <code>Handler</code> 类去继承 <code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_02.png" alt="" loading="lazy"></p>
<h2> 6.6 Pipeline 和 ChannelPipeline</h2>
<p><code>ChannelPipeline</code> 是一个重点：</p>
<ol>
<li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li>
<li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li>
<li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_03.png" alt="" loading="lazy"></p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_04.png" alt="" loading="lazy"></p>
<ol start="4">
<li>常用方法
<code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li>
</ol>
<h2> 6.7 ChannelHandlerContext</h2>
<ol>
<li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li>
<li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li>
<li>常用方法
<ul>
<li><code>ChannelFuture close()</code>，关闭通道</li>
<li><code>ChannelOutboundInvoker flush()</code>，刷新</li>
<li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到</li>
<li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li>
</ul>
</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_05.png" alt="" loading="lazy"></p>
<h2> 6.8 ChannelOption</h2>
<ol>
<li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li>
<li><code>ChannelOption</code> 参数如下：</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_06.png" alt="" loading="lazy"></p>
<h2> 6.9 EventLoopGroup 和其实现类 NioEventLoopGroup</h2>
<ol>
<li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li>
<li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li>
<li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_07.png" alt="" loading="lazy"></p>
<ol start="4">
<li>常用方法
<code>public NioEventLoopGroup()</code>，构造方法
<code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li>
</ol>
<h2> 6.10 Unpooled 类</h2>
<ol>
<li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li>
<li>常用方法如下所示</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_08.png" alt="" loading="lazy"></p>
<ol start="3">
<li>举例说明 <code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用【案例演示】</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_09.png" alt="" loading="lazy"></p>
<p>案例 1</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>案例 2</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6.11 Netty 应用实例-群聊系统</h2>
<p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li>
<li>目的：进一步理解 <code>Netty</code> 非阻塞网络编程机制</li>
<li>看老师代码演示</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_10.png" alt="" loading="lazy"></p>
<p>代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6.12 Netty 心跳检测机制案例</h2>
<p>实例要求：</p>
<ol>
<li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li>
<li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li>
<li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li>
<li>代码如下：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接</h2>
<p>实例要求：</p>
<ol>
<li><code>Http</code> 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。</li>
<li>要求：实现基于 <code>WebSocket</code> 的长连接的全双工的交互</li>
<li>改变 <code>Http</code> 协议多次请求的约束，实现长连接了，服务器可以发送消息给浏览器</li>
<li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li>
<li>运行界面</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_11.png" alt="" loading="lazy"></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter06_01.png" type="image/png"/>
    </item>
    <item>
      <title>第七章 Google Protobuf</title>
      <link>https://newzone.top/netty/chapter07.html</link>
      <guid>https://newzone.top/netty/chapter07.html</guid>
      <source url="https://newzone.top/rss.xml">第七章 Google Protobuf</source>
      <description>7.1 编码和解码的基本介绍</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 7.1 编码和解码的基本介绍</h2>
<ol>
<li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码[示意图]</li>
<li><code>codec</code>（编解码器）的组成部分有两个：<code>decoder</code>（解码器）和 <code>encoder</code>（编码器）。<code>encoder</code> 负责把业务数据转换成字节码数据，<code>decoder</code> 负责把字节码数据转换成业务数据</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter07_01.png" alt="" loading="lazy"></p>
<h2> 7.2 Netty 本身的编码解码的机制和问题分析</h2>
<ol>
<li>
<p><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)</p>
</li>
<li>
<p><code>Netty</code> 提供的编码器 <code>StringEncoder</code>，对字符串数据进行编码 <code>ObjectEncoder</code>，对Java对象进行编码...</p>
</li>
<li>
<p><code>Netty</code> 提供的解码器 <code>StringDecoder</code>,对字符串数据进行解码 <code>ObjectDecoder</code>，对 <code>Java</code> 对象进行解码...</p>
</li>
<li>
<p><code>Netty</code> 本身自带的 <code>ObjectDecoder</code> 和 <code>ObjectEncoder</code> 可以用来实现 <code>POJO</code> 对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，存在如下问题</p>
<ul>
<li>无法跨语言</li>
<li>序列化后的体积太大，是二进制编码的5倍多。</li>
<li>序列化性能太低</li>
</ul>
</li>
<li>
<p>=&gt;引出新的解决方案[<code>Google</code> 的 <code>Protobuf</code>]</p>
</li>
</ol>
<h2> 7.3 Protobuf</h2>
<ol>
<li><code>Protobuf</code> 基本介绍和使用示意图</li>
<li><code>Protobuf</code> 是 <code>Google</code> 发布的开源项目，全称 <code>Google Protocol Buffers</code>，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <code>RPC</code> [远程过程调用 <code>remote procedure call</code> ]数据交换格式。目前很多公司 <code>http + json tcp + protobuf</code></li>
<li>参考文档：<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener noreferrer">https://developers.google.com/protocol-buffers/docs/proto</a> 语言指南</li>
<li><code>Protobuf</code> 是以 <code>message</code> 的方式来管理数据的.</li>
<li>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的]（支持目前绝大多数语言，例如 <code>C++</code>、<code>C#</code>、<code>Java</code>、<code>python</code> 等）</li>
<li>高性能，高可靠性</li>
<li>使用 <code>protobuf</code> 编译器能自动生成代码，<code>Protobuf</code> 是将类的定义使用 <code>.proto</code> 文件进行描述。说明，在 <code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.ptoto</code> 编写插件.可以让语法高亮。</li>
<li>然后通过 <code>protoc.exe</code> 编译器根据 <code>.proto</code> 自动生成 <code>.java</code> 文件</li>
<li><code>protobuf</code> 使用示意图</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter07_02.png" alt="" loading="lazy"></p>
<h2> 7.4 Protobuf 快速入门实例</h2>
<p>编写程序，使用 <code>Protobuf</code> 完成如下功能</p>
<ol>
<li>客户端可以发送一个 <code>StudentPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li>
<li>服务端能接收 <code>StudentPoJo</code> 对象，并显示信息(通过 <code>Protobuf</code> 解码)</li>
<li>具体看老师演示步骤</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 7.5 Protobuf 快速入门实例 2</h2>
<ol>
<li>编写程序，使用 <code>Protobuf</code> 完成如下功能</li>
<li>客户端可以随机发送 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li>
<li>服务端能接收 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象(需要判断是哪种类型)，并显示信息(通过 <code>Protobuf</code> 解码)</li>
<li>具体看老师演示步骤</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter07_01.png" type="image/png"/>
    </item>
    <item>
      <title>第八章 Netty 编解码器和 Handler 调用机制</title>
      <link>https://newzone.top/netty/chapter08.html</link>
      <guid>https://newzone.top/netty/chapter08.html</guid>
      <source url="https://newzone.top/rss.xml">第八章 Netty 编解码器和 Handler 调用机制</source>
      <description>8.1 基本说明</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 8.1 基本说明</h2>
<ol>
<li><code>Netty</code> 的组件设计：<code>Netty</code> 的主要组件有 <code>Channel</code>、<code>EventLoop</code>、<code>ChannelFuture</code>、<code>ChannelHandler</code>、<code>ChannelPipe</code> 等</li>
<li><code>ChannelHandler</code> 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 <code>ChannelInboundHandler</code> 接口（或 <code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从 <code>ChannelInboundHandler</code> 冲刷数据。业务逻辑通常写在一个或者多个 <code>ChannelInboundHandler</code> 中。<code>ChannelOutboundHandler</code> 原理一样，只不过它是用来处理出站数据的</li>
<li><code>ChannelPipeline</code> 提供了 <code>ChannelHandler</code> 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 <code>pipeline</code> 中的一系列 <code>ChannelOutboundHandler</code>，并被这些 <code>Handler</code> 处理，反之则称为入站的</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter08_01.png" alt="" loading="lazy"></p>
<h2> 8.2编码解码器</h2>
<ol>
<li>当 <code>Netty</code> 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 <code>java</code> 对象）；如果是出站消息，它会被编码成字节。</li>
<li><code>Netty</code> 提供一系列实用的编解码器，他们都实现了 <code>ChannelInboundHadnler</code> 或者 <code>ChannelOutboundHandler</code> 接口。在这些类中，<code>channelRead</code> 方法已经被重写了。以入站为例，对于每个从入站 <code>Channel</code> 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 <code>decode()</code> 方法进行解码，并将已经解码的字节转发给 <code>ChannelPipeline</code> 中的下一个 <code>ChannelInboundHandler</code>。</li>
</ol>
<h2> 8.3 解码器 - ByteToMessageDecoder</h2>
<ol>
<li>关系继承图</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter08_02.png" alt="" loading="lazy"></p>
<ol start="2">
<li>由于不可能知道远程节点是否会一次性发送一个完整的信息，<code>tcp</code> 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.</li>
<li>一个关于 <code>ByteToMessageDecoder</code> 实例分析</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter08_03.png" alt="" loading="lazy"></p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter08_04.png" alt="" loading="lazy"></p>
<h2> 8.4 Netty 的 handler 链的调用机制</h2>
<p>实例要求:</p>
<ol>
<li>使用自定义的编码器和解码器来说明 <code>Netty</code> 的 <code>handler</code> 调用机制
客户端发送 <code>long</code> -&gt; 服务器
服务端发送 <code>long</code> -&gt; 客户端</li>
<li>案例演示</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter08_05.png" alt="" loading="lazy"></p>
<ol start="3">
<li>结论
<ul>
<li>不论解码器 <code>handler</code> 还是编码器 <code>handler</code> 即接收的消息类型必须与待处理的消息类型一致，否则该 <code>handler</code> 不会被执行</li>
<li>在解码器进行数据解码时，需要判断缓存区（<code>ByteBuf</code>）的数据是否足够，否则接收到的结果会期望结果可能不一致</li>
</ul>
</li>
</ol>
<h2> 8.5 解码器 - ReplayingDecoder</h2>
<ol>
<li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li>
<li><code>ReplayingDecoder</code> 扩展了 <code>ByteToMessageDecoder</code> 类，使用这个类，我们不必调用 <code>readableBytes()</code> 方法。参数 <code>S</code> 指定了用户状态管理的类型，其中 <code>Void</code> 代表不需要状态管理</li>
<li>应用实例：使用 <code>ReplayingDecoder</code> 编写解码器，对前面的案例进行简化[案例演示]</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li><code>ReplayingDecoder</code> 使用方便，但它也有一些局限性：
<ul>
<li>并不是所有的 <code>ByteBuf</code> 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li>
<li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于 <code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li>
</ul>
</li>
</ol>
<h2> 8.6 其它编解码器</h2>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter08_06.png" alt="" loading="lazy"></p>
<h3> 8.6.1 其它解码器</h3>
<ol>
<li><code>LineBasedFrameDecoder</code>：这个类在 <code>Netty</code> 内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</li>
<li><code>DelimiterBasedFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符。</li>
<li><code>HttpObjectDecoder</code>：一个 <code>HTTP</code> 数据的解码器</li>
<li><code>LengthFieldBasedFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li>
</ol>
<h3> 8.6.2 其它编码器</h3>
<h2> 8.7 Log4j 整合到 Netty</h2>
<ol>
<li>在 <code>Maven</code> 中添加对 <code>Log4j</code> 的依赖在 <code>pom.xml</code></li>
</ol>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>配置 <code>Log4j</code>，在 <code>resources/log4j.properties</code></li>
</ol>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>演示整合</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter08_07.png" alt="" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter08_01.png" type="image/png"/>
    </item>
    <item>
      <title>第九章 TCP 粘包和拆包及解决方案</title>
      <link>https://newzone.top/netty/chapter09.html</link>
      <guid>https://newzone.top/netty/chapter09.html</guid>
      <source url="https://newzone.top/rss.xml">第九章 TCP 粘包和拆包及解决方案</source>
      <description>9.1 TCP 粘包和拆包基本介绍</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 9.1 TCP 粘包和拆包基本介绍</h2>
<ol>
<li><code>TCP</code> 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 <code>socket</code>，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（<code>Nagle</code> 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的</li>
<li>由于 <code>TCP</code> 无消息保护边界,需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题,看一张图</li>
<li>示意图 <code>TCP</code> 粘包、拆包图解</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter09_01.png" alt="" loading="lazy"></p>
<p>对图的说明:
假设客户端分别发送了两个数据包 <code>D1</code> 和 <code>D2</code> 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p>
<ol>
<li>服务端分两次读取到了两个独立的数据包，分别是 <code>D1</code> 和 <code>D2</code>，没有粘包和拆包</li>
<li>服务端一次接受到了两个数据包，<code>D1</code> 和 <code>D2</code> 粘合在一起，称之为 <code>TCP</code> 粘包</li>
<li>服务端分两次读取到了数据包，第一次读取到了完整的 <code>D1</code> 包和 <code>D2</code> 包的部分内容，第二次读取到了 <code>D2</code> 包的剩余内容，这称之为 <code>TCP</code> 拆包</li>
<li>服务端分两次读取到了数据包，第一次读取到了 <code>D1</code> 包的部分内容 <code>D1_1</code>，第二次读取到了 <code>D1</code> 包的剩余部分内容 <code>D1_2</code> 和完整的 <code>D2</code> 包。</li>
</ol>
<h2> 9.2 TCP 粘包和拆包现象实例</h2>
<p>在编写 <code>Netty</code> 程序时，如果没有做处理，就会发生粘包和拆包的问题</p>
<p>看一个具体的实例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 9.3 TCP 粘包和拆包解决方案</h2>
<ol>
<li>使用自定义协议+编解码器来解决</li>
<li>关键就是要解决服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 <code>TCP</code> 粘包、拆包。</li>
</ol>
<h2> 9.4 看一个具体的实例</h2>
<ol>
<li>要求客户端发送 <code>5</code> 个 <code>Message</code> 对象，客户端每次发送一个 <code>Message</code> 对象</li>
<li>服务器端每次接收一个 <code>Message</code>，分 <code>5</code> 次进行解码，每读取到一个 <code>Message</code>，会回复一个 <code>Message</code> 对象给客户端。</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter09_02.png" alt="" loading="lazy"></p>
<ol start="3">
<li>代码演示，全部代码核心</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter09_01.png" type="image/png"/>
    </item>
    <item>
      <title>第十章 Netty 核心源码剖析</title>
      <link>https://newzone.top/netty/chapter10.html</link>
      <guid>https://newzone.top/netty/chapter10.html</guid>
      <source url="https://newzone.top/rss.xml">第十章 Netty 核心源码剖析</source>
      <description>10.1 基本说明</description>
      <category>Netty</category>
      <pubDate>Fri, 26 May 2023 11:06:46 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 10.1 基本说明</h2>
<ol>
<li>只有看过 <code>Netty</code> 源码，才能说是真的掌握了 <code>Netty</code> 框架。</li>
<li>在 <code>io.netty.example</code> 包下，有很多 <code>Netty</code> 源码案例，可以用来分析。</li>
<li>源码分析章节是针对有 <code>Java</code> 项目经验，并且玩过框架源码的人员讲的，否则你听起来会有相当的难度。</li>
</ol>
<h2> 10.2 Netty 启动过程源码剖析</h2>
<h3> 10.2.1 源码剖析目的</h3>
<p>用源码分析的方式走一下 <code>Netty</code>（服务器）的启动过程，更好的理解 <code>Netty</code> 的整体设计和运行机制。</p>
<h3> 10.2.2 源码剖析</h3>
<p>说明：</p>
<ol>
<li>源码需要剖析到 <code>Netty</code> 调用 <code>doBind</code> 方法，追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>。</li>
<li>并且要 <code>Debug</code> 程序到 <code>NioEventLoop</code> 类的 <code>run</code> 代码，无限循环，在服务器端运行。</li>
</ol>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_01.png" alt="" loading="lazy"></p>
<h3> 10.2.3 源码剖析过程</h3>
<p><strong>1. <code>demo</code> 源码的基本理解</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ol>
<li>先看启动类：<code>main</code> 方法中，首先创建了关于 SSL 的配置类。</li>
<li>重点分析下创建了两个 <code>EventLoopGroup</code> 对象：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>(1) 这两个对象是整个 <code>Netty</code> 的核心对象，可以说，整个 <code>Netty</code> 的运作都依赖于他们。<code>bossGroup</code> 用于接受 <code>TCP</code> 请求，他会将请求交给 <code>workerGroup</code>，<code>workerGroup</code> 会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。</p>
<p>(2) <code>EventLoopGroup</code> 是事件循环组（线程组）含有多个 <code>EventLoop</code>，可以注册 <code>channel</code>，用于在事件循环中去进行选择（和选择器相关）。【debug看】</p>
<p>(3) <code>new NioEventLoopGroup(1);</code> 这个 <code>1</code> 表示 <code>bossGroup</code> 事件组有 <code>1</code> 个线程你可以指定，如果 <code>new NioEventLoopGroup()</code> 会含有默认个线程 <code>cpu核数 * 2</code>，即可以充分的利用多核的优势，【可以dubug一把】</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>会创建 <code>EventExecutor</code> 数组 <code>children = new EventExecutor[nThreads];</code> // <code>debug</code> 一下每个元素的类型就是 <code>NIOEventLoop</code>，<code>NIOEventLoop</code> 实现了 <code>EventLoop</code> 接口和 <code>Executor</code> 接口 <code>try</code> 块中创建了一个 <code>ServerBootstrap</code> 对象，他是一个引导类，用于启动服务器和引导整个程序的初始化（看下源码 <code>allowseasybootstrapof{@linkServerChannel}</code>）。它和 <code>ServerChannel</code> 关联，而 <code>ServerChannel</code> 继承了 <code>Channel</code>，有一些方法 <code>remoteAddress</code> 等[可以Debug下]随后，变量 <code>b</code> 调用了 <code>group</code> 方法将两个 <code>group</code> 放入了自己的字段中，用于后期引导使用【<code>debug</code> 下 <code>group</code> 方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>】。</p>
<p>(4) 然后添加了一个 <code>channel</code>，其中参数一个 <code>Class</code> 对象，引导类将通过这个 <code>Class</code> 对象反射创建 <code>ChannelFactory</code>。然后添加了一些 <code>TCP</code> 的参数。【说明：<code>Channel</code> 的创建在 <code>bind</code> 方法，可以 <code>Debug</code> 下 <code>bind</code>，会找到 <code>channel = channelFactory.newChannel();</code> 】</p>
<p>(5) 再添加了一个服务器专属的日志处理器 <code>handler</code> 。</p>
<p>(6) 再添加一个 <code>SocketChannel</code>（不是 <code>ServerSocketChannel</code>）的 <code>handler</code>。</p>
<p>(7) 然后绑定端口并阻塞至连接成功。</p>
<p>(8) 最后 <code>main</code> 线程阻塞等待关闭。</p>
<p>(9) <code>finally</code> 块中的代码将在服务器关闭时优雅关闭所有资源。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明:</p>
<ol>
<li>这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。</li>
<li>大致讲解了我们的 <code>demo</code> 源码的作用。后面的 <code>debug</code> 的时候会详细。</li>
</ol>
<p><strong>2. 分析 EventLoopGroup 的过程</strong></p>
<p>2.1 构造器方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.2 上面的 <code>this(nThreads, (Executor) null);</code> 调用构造器（通过 <code>alt + d</code> 看即可）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.3 上面的 <code>this(nThreads, executor, SelectorProvider.provider());</code> 调用下面构造器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.4 上面的 <code>this()...</code> 调用构造器（<code>alt + d</code>）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.5 上面的 <code>super()..</code> 的方法是父类：<code>MultithreadEventLoopGroup</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.6 追踪到源码抽象类 <code>MultithreadEventExecutorGroup</code> 的构造器方法 <code>MultithreadEventExecutorGroup</code> 才是 <code>NioEventLoopGroup</code> 真正的构造方法，这里可以看成是一个模板方法，使用了设计模式的模板模式（可看我录制视频），所以，我们就需要好好分析 <code>MultithreadEventExecutorGroup</code> 方法了</p>
<p>2.7 分析 <code>MultithreadEventExecutorGroup</code></p>
<p>参数说明：</p>
<ul>
<li><code>@param nThreads</code> 使用的线程数，默认为 <code>core * 2</code>【可以追踪源码】</li>
<li><code>@param executor</code> 执行器:如果传入 <code>null</code>, 则采用 <code>Netty</code> 默认的线程工厂和默认的执行器 <code>ThreadPerTaskExecutor</code></li>
<li><code>@param chooserFactory</code> 单例 <code>new DefaultEventExecutorChooserFactory()</code></li>
<li><code>@param args args</code> 在创建执行器的时候传入固定参数</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ol>
<li>如果 <code>executor</code> 是 <code>null</code>，创建一个默认的 <code>ThreadPerTaskExecutor</code>，使用 <code>Netty</code> 默认的线程工厂。</li>
<li>根据传入的线程数（<code>CPU * 2</code>）创建一个线程池（单例线程池）数组。</li>
<li>循环填充数组中的元素。如果异常，则关闭所有的单例线程池。</li>
<li>根据线程选择工厂创建一个线程选择器。</li>
<li>为每一个单例线程池添加一个关闭监听器。</li>
<li>将所有的单例线程池添加到一个 <code>HashSet</code> 中。</li>
</ol>
<p><strong>3. ServerBootstrap 创建和构造过程</strong></p>
<p>3.1 <code>ServerBootstrap</code> 是个空构造，但是有默认的成员变量</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.2 分析一下 <code>ServerBootstrap</code> 基本使用情况</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明:</p>
<ol>
<li>链式调用：<code>group</code> 方法，将 <code>boss</code> 和 <code>worker</code> 传入，<code>boss</code> 赋值给 <code>parentGroup</code> 属性, <code>worker</code> 赋值给 <code>childGroup</code> 属性。</li>
<li><code>channel</code> 方法传入 <code>NioServerSocketChannelclass</code> 对象。会根据这个 <code>class</code> 创建 <code>channel</code> 对象。</li>
<li><code>option</code> 方法传入 <code>TCP</code> 参数，放在一个 <code>LinkedHashMap</code> 中。</li>
<li><code>handler</code> 方法传入一个 <code>handler</code> 中，这个 <code>hanlder</code> 只专属于 <code>ServerSocketChannel</code> 而不是 <code>SocketChannel</code>。</li>
<li><code>childHandler</code> 传入一个 <code>hanlder</code>，这个 <code>handler</code> 将会在每个客户端连接的时候调用。供 <code>SocketChannel</code> 使用。</li>
</ol>
<p><strong>4. 绑定端口的分析</strong></p>
<p>4.1 服务器就是在这个 <code>bind</code> 方法里启动完成的
4.2 <code>bind</code> 方法代码,追踪到创建了一个端口对象，并做了一些空判断，核心代码 <code>doBind</code>，我们看看</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.3 <code>doBind</code> 源码剖析，核心是两个方法 <code>initAndRegister</code> 和 <code>doBind0</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.4 分析说明 <code>initAndRegister</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ol>
<li>基本说明：<code>initAndRegister()</code> 初始化 <code>NioServerSocketChannel</code> 通道并注册各个 <code>handler</code>，返回一个 <code>future</code>。</li>
<li>通过 <code>ServerBootstrap</code> 的通道工厂反射创建一个 <code>NioServerSocketChannel</code>。</li>
<li><code>init</code> 初始化这个 <code>NioServerSocketChannel</code>。</li>
<li><code>config().group().register(channel)</code> 通过 <code>ServerBootstrap</code> 的 <code>bossGroup</code> 注册 <code>NioServerSocketChannel</code>。</li>
<li>最后，返回这个异步执行的占位符即 <code>regFuture</code>。</li>
</ol>
<p>4.5 <code>init</code> 方法会调用 <code>addLast</code>，现在进入到 <code>addLast</code> 方法内查看</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ol>
<li><code>addLast</code> 方法，在 <code>DefaultChannelPipeline</code> 类中</li>
<li><code>addLast</code> 方法这就是 <code>pipeline</code> 方法的核心</li>
<li>检查该 <code>handler</code> 是否符合标准。</li>
<li>创建一个 <code>AbstractChannelHandlerContext</code> 对象，这里说一下，<code>ChannelHandlerContext</code> 对象是 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关联，每当有 <code>ChannelHandler</code> 添加到 <code>Pipeline</code> 中时，都会创建 <code>Context</code>。<code>Context</code> 的主要功能是管理他所关联的 <code>Handler</code> 和同一个 <code>Pipeline</code> 中的其他 <code>Handler</code> 之间的交互。</li>
<li>将 <code>Context</code> 添加到链表中。也就是追加到 <code>tail</code> 节点的前面。</li>
<li>最后，同步或者异步或者晚点异步的调用 <code>callHandlerAdded0</code> 方法</li>
</ol>
<p>4.6 前面说了 <code>dobind</code> 方法有 <code>2</code> 个重要的步骤，<code>initAndRegister</code> 说完，接下来看 <code>doBind0</code> 方法，代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<ol>
<li>该方法的参数为 <code>initAndRegister</code> 的 <code>future</code>，<code>NioServerSocketChannel</code>，端口地址，<code>NioServerSocketChannel</code> 的 <code>promise</code></li>
<li>这里就可以根据前面下的断点，一直 <code>debug</code>：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>最终 <code>doBind</code> 就会追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>，说明 <code>Netty</code> 底层使用的是 <code>NIO</code></li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>
<p>回到 <code>bind</code> 方法（<code>alt + v</code>），最后一步：<code>safeSetSuccess(promise)</code>，告诉 <code>promise</code> 任务成功了。其可以执行监听器的方法了。到此整个启动过程已经结束了，ok 了</p>
</li>
<li>
<p>继续 <code>atl + v</code> 服务器就回进入到（<code>NioEventLoop</code> 类）一个循环代码，进行监听</p>
</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10.2.4 Netty 启动过程梳理</h3>
<ol>
<li>创建 <code>2</code> 个 <code>EventLoopGroup</code> 线程池数组。数组默认大小 <code>CPU * 2</code>，方便 <code>chooser</code> 选择线程池时提高性能</li>
<li><code>BootStrap</code> 将 <code>boss</code> 设置为 <code>group</code> 属性，将 <code>worker</code> 设置为 <code>childer</code> 属性</li>
<li>通过 <code>bind</code> 方法启动，内部重要方法为 <code>initAndRegister</code> 和 <code>dobind</code> 方法</li>
<li><code>initAndRegister</code> 方法会反射创建 <code>NioServerSocketChannel</code> 及其相关的 <code>NIO</code> 的对象，<code>pipeline</code>，<code>unsafe</code>，同时也为 <code>pipeline</code> 初始了 <code>head</code> 节点和 <code>tail</code> 节点。</li>
<li>在 <code>register0</code> 方法成功以后调用在 <code>dobind</code> 方法中调用 <code>doBind0</code> 方法，该方法会调用 <code>NioServerSocketChannel</code> 的 <code>doBind</code> 方法对 <code>JDK</code> 的 <code>channel</code> 和端口进行绑定，完成 <code>Netty</code> 服务器的所有启动，并开始监听连接事件。</li>
</ol>
<h2> 10.3 Netty 接受请求过程源码剖析</h2>
<h3> 10.3.1 源码剖析目的</h3>
<ol>
<li>服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分析 <code>Netty</code> 在启动之后是如何接受客户端请求的</li>
<li>在 <code>io.netty.example</code> 包下</li>
</ol>
<h3> 10.3.2 源码剖析</h3>
<p>说明：</p>
<ol>
<li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 <code>Accept</code> 事件等待客户端的连接。我们也知道，<code>NioServerSocketChannel</code> 将自己注册到了 <code>boss</code> 单例线程池（<code>reactor</code> 线程）上，也就是 <code>EventLoop</code>。</li>
<li>先简单说下 <code>EventLoop</code> 的逻辑(后面我们详细讲解 <code>EventLoop</code>)</li>
</ol>
<p><code>EventLoop</code> 的作用是一个死循环，而这个循环中做 3 件事情：</p>
<ol>
<li>有条件的等待 <code>NIO</code> 事件。</li>
<li>处理 <code>NIO</code> 事件。</li>
<li>处理消息队列中的任务。</li>
<li>仍用前面的项目来分析：进入到 <code>NioEventLoop</code> 源码中后，在 <code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法开始调试最终我们要分析到 <code>AbstractNioChannel</code> 的 <code>doBeginRead</code> 方法，当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li>
</ol>
<p>源码分析过程</p>
<ol>
<li>断点位置 <code>NioEventLoop</code> 的如下方法 <code>processSelectedKey</code></li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>执行浏览器 <code>http://localhost:8007/</code> ，客户端发出请求</li>
<li>从的断点我们可以看到，<code>readyOps</code> 是 <code>16</code>，也就是 <code>Accept</code> 事件。说明浏览器的请求已经进来了。</li>
<li>这个 <code>unsafe</code> 是 <code>boss</code> 线程中 <code>NioServerSocketChannel</code> 的 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 对象。我们进入到 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 的 <code>read</code> 方法中</li>
<li><code>read</code> 方法代码并分析:</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：
1)检查该 <code>eventloop</code> 线程是否是当前线程。<code>asserteventLoop().inEventLoop()</code></p>
<p>2)执行 <code>doReadMessages</code> 方法，并传入一个 <code>readBuf</code> 变量，这个变量是一个 <code>List</code>，也就是容器。</p>
<p>3)循环容器，执行 <code>pipeline.fireChannelRead(readBuf.get(i));</code></p>
<p>4)<code>doReadMessages</code> 是读取 <code>boss</code> 线程中的 <code>NioServerSocketChannel</code> 接受到的请求。并把这些请求放进容器，一会我们 <code>debug</code> 下 <code>doReadMessages</code> 方法。</p>
<p>5)循环遍历容器中的所有请求，调用 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法，用于处理这些接受的请求或者其他事件，在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p>
<ol start="6">
<li>追踪一下 <code>doReadMessages</code> 方法，就可以看得更清晰</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：
1)通过工具类，调用 <code>NioServerSocketChannel</code> 内部封装的 <code>serverSocketChannel</code> 的 <code>accept</code> 方法，这是 <code>NIO</code> 做法。</p>
<p>2)获取到一个 <code>JDK</code> 的 <code>SocketChannel</code>，然后，使用 <code>NioSocketChannel</code> 进行封装。最后添加到容器中</p>
<p>3)这样容器 <code>buf</code> 中就有了 <code>NioSocketChannel</code> 【如果有兴趣可以追一下 <code>NioSocketChannel</code> 是如何创建的，我就不追了】</p>
<ol start="7">
<li>回到 <code>read</code> 方法，继续分析循环执行 <code>pipeline.fireChannelRead</code> 方法</li>
</ol>
<p>1)前面分析 <code>doReadMessages</code> 方法的作用是通过 <code>ServerSocket</code> 的 <code>accept</code> 方法获取到 <code>TCP</code> 连接，然后封装成 <code>Netty</code> 的 <code>NioSocketChannel</code> 对象。最后添加到容器中</p>
<p>2)在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p>
<p>3)经过 <code>dubug</code>（多次），可以看到会反复执行多个 <code>handler</code> 的 <code>ChannelRead</code>，我们知道，<code>pipeline</code> 里面又 <code>4</code> 个 <code>handler</code>，分别是 <code>Head</code>，<code>LoggingHandler</code>，<code>ServerBootstrapAcceptor</code>，<code>Tail</code>。</p>
<p>4)我们重点看看 <code>ServerBootstrapAcceptor</code>。<code>debug</code> 之后，断点会进入到 <code>ServerBootstrapAcceptor</code> 中来。我们来看看 <code>ServerBootstrapAcceptor</code> 的 <code>channelRead</code> 方法（要多次 <code>debug</code> 才可以）</p>
<p>5)<code>channelRead</code> 方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：
1)<code>msg</code> 强转成 <code>Channel</code>，实际上就是 <code>NioSocketChannel</code>。</p>
<p>2)添加 <code>NioSocketChannel</code> 的 <code>pipeline</code> 的 <code>handler</code>，就是我们 <code>main</code> 方法里面设置的 <code>childHandler</code> 方法里的。</p>
<p>3)设置 <code>NioSocketChannel</code> 的各种属性。</p>
<p>4)将该 <code>NioSocketChannel</code> 注册到 <code>childGroup</code> 中的一个 <code>EventLoop</code> 上，并添加一个监听器。</p>
<p>5)这个 <code>childGroup</code> 就是我们 <code>main</code> 方法创建的数组 <code>workerGroup</code>。</p>
<ol start="8">
<li>进入 <code>register</code> 方法查看(步步追踪会到)</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="9">
<li>最终会调用 <code>doBeginRead</code> 方法，也就是 <code>AbstractNioChannel</code> 类的方法</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="10">
<li>这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在 <code>doBeginRead</code>（需要先放过该断点，然后浏览器请求，才能看到效果）</li>
<li>执行到这里时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li>
</ol>
<h3> 10.3.3 Netty 接受请求过程梳理</h3>
<p>总体流程：接受连接 --&gt; 创建一个新的 <code>NioSocketChannel</code> --&gt; 注册到一个 <code>workerEventLoop</code> 上 --&gt; 注册 <code>selecotRead</code> 事件。</p>
<ol>
<li>服务器轮询 <code>Accept</code> 事件，获取事件后调用 <code>unsafe</code> 的 <code>read</code> 方法，这个 <code>unsafe</code> 是 <code>ServerSocket</code> 的内部类，该方法内部由 <code>2</code> 部分组成</li>
<li><code>doReadMessages</code> 用于创建 <code>NioSocketChannel</code> 对象，该对象包装 <code>JDK</code> 的 <code>NioChannel</code> 客户端。该方法会像创建 <code>ServerSocketChanel</code> 类似创建相关的 <code>pipeline</code>，<code>unsafe</code>，<code>config</code></li>
<li>随后执行执行 <code>pipeline.fireChannelRead</code> 方法，并将自己绑定到一个 <code>chooser</code> 选择器选择的 <code>workerGroup</code> 中的一个 <code>EventLoop</code>。并且注册一个 <code>0</code>，表示注册成功，但并没有注册读（1）事件</li>
</ol>
<h2> 10.4 Pipeline Handler HandlerContext 创建源码剖析</h2>
<h3> 10.4.1 源码剖析目的</h3>
<p><code>Netty</code> 中的 <code>ChannelPipeline</code>、<code>ChannelHandler</code> 和 <code>ChannelHandlerContext</code> 是非常核心的组件，我们从源码来分析 <code>Netty</code> 是如何设计这三个核心组件的，并分析是如何创建和协调工作的.</p>
<h3> 10.4.2 源码剖析说明</h3>
<p>说明
分析过程中，有很多的图形，所以我们准备了一个文档，在文档的基础上来做源码剖析</p>
<h3> 10.4.3 源码剖析</h3>
<ol>
<li>ChannelPipeline | ChannelHandler | ChannelHandlerContext介绍
1.1 三者关系</li>
</ol>
<p>1)每当 <code>ServerSocket</code> 创建一个新的连接，就会创建一个 <code>Socket</code>，对应的就是目标客户端。</p>
<p>2)每一个新创建的 <code>Socket</code> 都将会分配一个全新的 <code>ChannelPipeline</code>（以下简称 <code>pipeline</code>）</p>
<p>3)每一个 <code>ChannelPipeline</code> 内部都含有多个 <code>ChannelHandlerContext</code>（以下简称 <code>Context</code>）</p>
<p>4)他们一起组成了双向链表，这些 <code>Context</code> 用于包装我们调用 <code>addLast</code> 方法时添加的 <code>ChannelHandler</code>（以下简称 <code>handler</code>）</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_02.png" alt="" loading="lazy"></p>
<p>1)上图中：<code>ChannelSocket</code> 和 <code>ChannelPipeline</code> 是一对一的关联关系，而 <code>pipeline</code> 内部的多个 <code>Context</code> 形成了链表，<code>Context</code> 只是对 <code>Handler</code> 的封装。
2)当一个请求进来的时候，会进入 <code>Socket</code> 对应的 <code>pipeline</code>，并经过 <code>pipeline</code> 所有的 <code>handler</code>，对，就是设计模式中的过滤器模式。</p>
<p>1.2 ChannelPipeline 作用及设计</p>
<p>1)<code>pipeline</code> 的接口设计</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_03.png" alt="" loading="lazy"></p>
<p>部分源码</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_04.png" alt="" loading="lazy"></p>
<p>可以看到该接口继承了 <code>inBound</code>，<code>outBound</code>，<code>Iterable</code> 接口，表示他可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表，看看他的几个代表性的方法，基本上都是针对 <code>handler</code> 链表的插入，追加，删除，替换操作，类似是一个 <code>LinkedList</code>。同时，也能返回 <code>channel</code>（也就是 <code>socket</code>）</p>
<p>1)在 <code>pipeline</code> 的接口文档上，提供了一幅图</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_05.png" alt="" loading="lazy"></p>
<p>对上图的解释说明：
*这是一个 <code>handler</code> 的 <code>list</code>，<code>handler</code> 用于处理或拦截入站事件和出站事件，<code>pipeline</code> 实现了过滤器的高级形式，以便用户控制事件如何处理以及 <code>handler</code> 在 <code>pipeline</code> 中如何交互。</p>
<p>*上图描述了一个典型的 <code>handler</code> 在 <code>pipeline</code> 中处理 <code>I/O</code> 事件的方式，<code>IO</code> 事件由 <code>inboundHandler</code> 或者 <code>outBoundHandler</code> 处理，并通过调用 <code>ChannelHandlerContext.fireChannelRead</code> 方法转发给其最近的处理程序。</p>
<p>*入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 <code>I/O</code> 线程生成入站数据。入站数据通常从如 <code>SocketChannel.read(ByteBuffer)</code> 获取。</p>
<p>*通常一个 <code>pipeline</code> 有多个 <code>handler</code>，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序协议解码器-将二进制数据转换为 <code>Java</code> 对象。协议编码器-将 <code>Java</code> 对象转换为二进制数据。业务逻辑处理程序-执行实际业务逻辑（例如数据库访问）</p>
<p>*你的业务程序不能将线程阻塞，会影响 <code>IO</code> 的速度，进而影响整个 <code>Netty</code> 程序的性能。如果你的业务程序很快，就可以放在 <code>IO</code> 线程中，反之，你需要异步执行。或者在添加 <code>handler</code> 的时候添加一个线程池，例如：</p>
<p>// 下面这个任务执行的时候，将不会阻塞 <code>IO</code> 线程，执行的线程来自 <code>group</code> 线程池</p>
<p><code>pipeline.addLast(group, "handler", new MyBusinessLogicHandler());</code></p>
<p>1.3 <code>ChannelHandler</code> 作用及设计</p>
<p>1)源码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2)<code>ChannelHandler</code> 的作用就是处理 <code>IO</code> 事件或拦截 <code>IO</code> 事件，并将其转发给下一个处理程序 <code>ChannelHandler</code>。<code>Handler</code> 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，<code>Netty</code> 定义了两个子接口继承 <code>ChannelHandler</code></p>
<p>2)<code>ChannelInboundHandler</code> 入站事件接口</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_06.png" alt="" loading="lazy"></p>
<p>*<code>channelActive</code> 用于当 <code>Channel</code> 处于活动状态时被调用；</p>
<p>*<code>channelRead</code> 当从 <code>Channel</code> 读取数据时被调用等等方法。</p>
<p>*程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，<code>Netty</code> 会回调对应的方法。</p>
<p>3)`ChannelOutboundHandler 出站事件接口</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_07.png" alt="" loading="lazy"></p>
<p>*<code>bind</code> 方法，当请求将 <code>Channel</code> 绑定到本地地址时调用</p>
<p>*<code>close</code> 方法，当请求关闭 <code>Channel</code> 时调用等等</p>
<p>*出站操作都是一些连接和写出数据类似的方法。</p>
<p>4)<code>ChannelDuplexHandler</code> 处理出站和入站事件</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_08.png" alt="" loading="lazy"></p>
<p>*<code>ChannelDuplexHandler</code> 间接实现了入站接口并直接实现了出站接口。</p>
<p>*是一个通用的能够同时处理入站事件和出站事件的类。</p>
<p>1.4 <code>ChannelHandlerContext</code> 作用及设计</p>
<p>1)<code>ChannelHandlerContext</code> <code>UML</code> 图</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_09.png" alt="" loading="lazy"></p>
<p><code>ChannelHandlerContext</code> 继承了出站方法调用接口和入站方法调用接口</p>
<p>1)<code>ChannelOutboundInvoker</code> 和 <code>ChannelInboundInvoker</code> 部分源码</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_10.png" alt="" loading="lazy"></p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_11.png" alt="" loading="lazy"></p>
<p>*这两个 <code>invoker</code> 就是针对入站或出站方法来的，就是在入站或出站 <code>handler</code> 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的</p>
<p>2)<code>ChannelHandlerContext</code> 部分源码</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_12.png" alt="" loading="lazy"></p>
<p>*<code>ChannelHandlerContext</code> 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法</p>
<p>*这些方法能够获取 <code>Context</code> 上下文环境中对应的比如 <code>channel</code>，<code>executor</code>，<code>handler</code>，<code>pipeline</code>，内存分配器，关联的 <code>handler</code> 是否被删除。</p>
<p>*<code>Context</code> 就是包装了 <code>handler</code> 相关的一切，以方便 <code>Context</code> 可以在 <code>pipeline</code> 方便的操作 <code>handler</code></p>
<p>2.ChannelPipeline | ChannelHandler | ChannelHandlerContext</p>
<p>创建过程分为 <code>3</code> 个步骤来看创建的过程：</p>
<p>*任何一个 <code>ChannelSocket</code> 创建的同时都会创建一个 <code>pipeline</code>。</p>
<p>*当用户或系统内部调用 <code>pipeline</code> 的 <code>add</code></p>
<p>*** 方法添加 <code>handler</code> 时，都会创建一个包装这 <code>handler</code> 的 <code>Context</code>。</p>
<p>*这些 <code>Context</code> 在 <code>pipeline</code> 中组成了双向链表。</p>
<p>2.1 <code>Socket</code> 创建的时候创建 <code>pipeline</code> 在 <code>SocketChannel</code> 的抽象父类 <code>AbstractChannel</code> 的构造方法中</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Debug</code> 一下，可以看到代码会执行到这里，然后继续追踪到</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<p>1）将 <code>channel</code> 赋值给 <code>channel</code> 字段，用于 <code>pipeline</code> 操作 <code>channel</code>。</p>
<p>2）创建一个 <code>future</code> 和 <code>promise</code>，用于异步回调使用。</p>
<p>3）创建一个 <code>inbound</code> 的 <code>tailContext</code>，创建一个既是 <code>inbound</code> 类型又是 <code>outbound</code> 类型的 <code>headContext</code>。</p>
<p>4）最后，将两个 <code>Context</code> 互相连接，形成双向链表。</p>
<p>5）<code>tailContext</code> 和 <code>HeadContext</code> 非常的重要，所有 <code>pipeline</code> 中的事件都会流经他们，</p>
<p>2.2 在 add<strong>添加处理器的时候创建Context</strong>看下 <code>DefaultChannelPipeline</code> 的 <code>addLast</code> 方法如何创建的 <code>Context</code>，代码如下</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>继续 Debug</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明
1)<code>pipeline</code> 添加 <code>handler</code>，参数是线程池，<code>name</code> 是 <code>null</code>，<code>handler</code> 是我们或者系统传入的 <code>handler</code>。<code>Netty</code> 为了防止多个线程导致安全问题，同步了这段代码，步骤如下：</p>
<p>2)检查这个 <code>handler</code> 实例是否是共享的，如果不是，并且已经被别的 <code>pipeline</code> 使用了，则抛出异常。</p>
<p>3)调用 <code>new Context(group, filterName(name, handler), handler)</code> 方法，创建一个 <code>Context</code>。从这里可以看出来了，每次添加一个 <code>handler</code> 都会创建一个关联 <code>Context</code>。</p>
<p>4)调用 <code>addLast</code> 方法，将 <code>Context</code> 追加到链表中。</p>
<p>5)如果这个通道还没有注册到 <code>selecor</code> 上，就将这个 <code>Context</code> 添加到这个 <code>pipeline</code> 的待办任务中。当注册好了以后，就会调用 <code>callHandlerAdded0</code> 方法（默认是什么都不做，用户可以实现这个方法）。</p>
<p>6)到这里，针对三对象创建过程，了解的差不多了，和最初说的一样，每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。<code>tail</code> 是入站 <code>inbound</code> 类型的 <code>handler</code>，<code>head</code> 既是 <code>inbound</code> 也是 <code>outbound</code> 类型的 <code>handler</code>。在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。到此就 <code>OK</code> 了。</p>
<h3> 10.4.4 Pipeline Handler HandlerContext 创建过程梳理</h3>
<ol>
<li>每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。</li>
<li>在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。</li>
<li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表</li>
<li>入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始</li>
</ol>
<h2> 10.5 ChannelPipeline 调度 handler 的源码剖析</h2>
<h3> 10.5.1 源码剖析目的</h3>
<ol>
<li>当一个请求进来的时候，<code>ChannelPipeline</code> 是如何调用内部的这些 <code>handler</code> 的呢？我们一起来分析下。</li>
<li>首先，当一个请求进来的时候，会第一个调用 <code>pipeline</code> 的相关方法，如果是入站事件，这些方法由 <code>fire</code> 开头，表示开始管道的流动。让后面的 <code>handler</code> 继续处理</li>
</ol>
<h3> 10.5.2 源码剖析</h3>
<p>说明</p>
<p>当浏览器输入 <code>http://localhost:8007</code> 。可以看到会执行 <code>handler</code>
在 <code>Debug</code> 时，可以将断点下在 <code>DefaultChannelPipeline</code> 类的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>源码分析</p>
<ol start="3">
<li><code>DefaultChannelPipeline</code> 是如何实现这些 <code>fire</code> 方法的
3.1 <code>DefaultChannelPipeline</code> 源码</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：
可以看出来，这些方法都是 <code>inbound</code> 的方法，也就是入站事件，调用静态方法传入的也是 <code>inbound</code> 的类型 <code>head</code> <code>handler</code>。这些静态方法则会调用 <code>head</code> 的 <code>ChannelInboundInvoker</code> 接口的方法，再然后调用 <code>handler</code> 的真正方法</p>
<p>3.2再看下 <code>piepline</code> 的 <code>outbound</code> 的 <code>fire</code> 方法实现源码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<p>1)这些都是出站的实现，但是调用的是 <code>outbound</code> 类型的 <code>tailhandler</code> 来进行处理，因为这些都是 <code>outbound</code> 事件。</p>
<p>2)出站是 <code>tail</code> 开始，入站从 <code>head</code> 开始。因为出站是从内部向外面写，从 <code>tail</code> 开始，能够让前面的 <code>handler</code> 进行处理，防止 <code>handler</code> 被遗漏，比如编码。反之，入站当然是从 <code>head</code> 往内部输入，让后面的 <code>handler</code> 能够处理这些输入的数据。比如解码。因此虽然 <code>head</code> 也实现了 <code>outbound</code> 接口，但不是从 head 开始执行出站任务</p>
<p>4.关于如何调度，用一张图来表示:</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_13.png" alt="" loading="lazy"></p>
<p>说明：
1)<code>pipeline</code> 首先会调用 <code>Context</code> 的静态方法 <code>fireXXX</code>，并传入 <code>Context</code></p>
<p>2)然后，静态方法调用 <code>Context</code> 的 <code>invoker</code> 方法，而 <code>invoker</code> 方法内部会调用该 <code>Context</code> 所包含的 <code>Handler</code> 的真正的 <code>XXX</code> 方法，调用结束后，如果还需要继续向后传递，就调用 <code>Context</code> 的 <code>fireXXX2</code> 方法，循环往复。</p>
<h3> 10.5.3 ChannelPipeline 调度 handler 梳理</h3>
<ol>
<li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表，入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始。</li>
<li>而节点中间的传递通过 <code>Abstract ChannelHandlerContext</code> 类内部的 <code>fire</code> 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对 <code>handler</code> 的调度</li>
</ol>
<h2> 10.6 Netty 心跳(heartbeat)服务源码剖析</h2>
<h3> 10.6.1 源码剖析目的</h3>
<p><code>Netty</code> 作为一个网络框架，提供了诸多功能，比如编码解码等，<code>Netty</code> 还提供了非常重要的一个服务 -- 心跳机制 <code>heartbeat</code>。通过心跳检查对方是否有效，这是 <code>RPC</code> 框架中是必不可少的功能。下面我们分析一下 <code>Netty</code> 内部心跳服务源码实现。</p>
<h3> 10.6.2 源码剖析</h3>
<p>说明</p>
<p><code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性，重点分析 <code>IdleStateHandler</code>。</p>
<p>如图</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_14.png" alt="" loading="lazy"></p>
<p>源码剖析：</p>
<p>5.<code>Netty</code> 提供的心跳介绍</p>
<p>1)<code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性。</p>
<p>2)如图</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_15.png" alt="" loading="lazy"></p>
<p>3)<code>ReadTimeout</code> 事件和 <code>WriteTimeout</code> 事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以下，我们重点看 <code>IdleStateHandler</code>。</p>
<p>6.<code>IdleStateHandler</code> 分析</p>
<p>6.1 <code>4</code> 个属性</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>6.2<code>handlerAdded</code> 方法</p>
<p>当该 <code>handler</code> 被添加到 <code>pipeline</code> 中时，则调用 <code>initialize</code> 方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只要给定的参数大于 <code>0</code>，就创建一个定时任务，每个事件都创建。同时，将 <code>state</code> 状态设置为 <code>1</code>，防止重复初始化。调用 <code>initOutputChanged</code> 方法，初始化“监控出站数据属性”。</p>
<p>6.3该类内部的 <code>3</code> 个定时任务类</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_16.png" alt="" loading="lazy"></p>
<p>1)这 <code>3</code> 个定时任务分别对应读，写，读或者写事件。共有一个父类（<code>AbstractIdleTask</code>）。这个父类提供了一个模板方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：当通道关闭了，就不执行任务了。反之，执行子类的 <code>run</code> 方法</p>
<p>7.读事件的 <code>run</code> 方法（即 <code>ReaderIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>
<p>1)代码及其说明</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<p>1)得到用户设置的超时时间。</p>
<p>2)如果读取操作结束了（执行了 <code>channelReadComplete</code> 方法设置），就用当前时间减去给定时间和最后一次读（执操作的时间行了 <code>channelReadComplete</code> 方法设置），如果小于 <code>0</code>，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。</p>
<p>3)触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 <code>promise</code> 对象，用于做取消操作。然后，设置 <code>first</code> 属性为<code>false</code>，表示，下一次读取不再是第一次了，这个属性在 <code>channelRead</code> 方法会被改成 <code>true</code>。</p>
<p>4)创建一个 <code>IdleStateEvent</code> 类型的写事件对象，将此对象传递给用户的 <code>UserEventTriggered</code> 方法。完成触发事件的操作。</p>
<p>5)总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 <code>UserEventTriggered</code> 方法。//前面介绍 <code>IdleStateHandler</code> 说过,可以看一下</p>
<p>8.写事件的 <code>run</code> 方法（即 <code>WriterIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>
<p>1)<code>run</code> 代码和分析</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：写任务的 <code>run</code> 代码逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对出站较慢数据的判断 <code>hasOutputChanged</code></p>
<p>9.所有事件的 <code>run</code> 方法（即 <code>AllIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p>
<p>代码分析</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<p>1)表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致：</p>
<p>2)需要大家注意的地方是</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3)这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。</p>
<p>10.小结 <code>Netty</code> 的心跳机制</p>
<p>1)<code>IdleStateHandler</code> 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 <code>handler</code> 的 <code>userEventTriggered</code> 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。</p>
<p>2)<code>IdleStateHandler</code> 的实现基于 <code>EventLoop</code> 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</p>
<p>3)内部有 <code>3</code> 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。</p>
<p>4)同时，<code>IdleStateHandler</code> 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。<code>Netty</code> 通过构造方法中的 <code>observeOutput</code> 属性来决定是否对出站缓冲区的情况进行判断。</p>
<p>5)如果出站缓慢，<code>Netty</code> 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 <code>OOM</code>，<code>OOM</code> 比空闲的问题更大。</p>
<p>6)所以，当你的应用出现了内存溢出，<code>OOM</code> 之类，并且写空闲极少发生（使用了 <code>observeOutput</code> 为 <code>true</code>），那么就需要注意是不是数据出站速度过慢。</p>
<p>7)还有一个注意的地方：就是 <code>ReadTimeoutHandler</code>，它继承自 <code>IdleStateHandler</code>，当触发读空闲事件的时候，就触发 <code>ctx</code>. <code>fireExceptionCaught</code> 方法，并传入一个 <code>ReadTimeoutException</code>，然后关闭 <code>Socket</code>。</p>
<p>8)而 <code>WriteTimeoutHandler</code> 的实现不是基于 <code>IdleStateHandler</code> 的，他的原理是，当调用 <code>write</code> 方法的时候，会创建一个定时任务，任务内容是根据传入的 <code>promise</code> 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 <code>promise</code> 的 <code>isDone</code> 方法返回 <code>false</code>，表明还没有写完，说明超时了，则抛出异常。当 <code>write</code> 方法完成后，会打断定时任务。</p>
<h2> 10.7 Netty 核心组件 EventLoop 源码剖析</h2>
<h3> 10.7.1 源码剖析目的</h3>
<p><code>Echo</code> 第一行代码就是：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1)</code>; 下面分析其最核心的组件 <code>EventLoop</code>。</p>
<h3> 10.7.2 源码剖析</h3>
<p>源码剖析</p>
<p>1.<code>EventLoop</code>介绍
1.1首先看看 <code>NioEventLoop</code> 的继承图</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_17.png" alt="" loading="lazy"></p>
<p>说明重点：
1)<code>ScheduledExecutorService</code> 接口表示是一个定时任务接口，<code>EventLoop</code> 可以接受定时任务。</p>
<p>2)<code>EventLoop</code> 接口：<code>Netty</code> 接口文档说明该接口作用：一旦 <code>Channel</code> 注册了，就处理该 <code>Channel</code> 对应的所有 <code>I/O</code> 操作。</p>
<p>3)<code>SingleThreadEventExecutor</code> 表示这是一个单个线程的线程池</p>
<p>4)<code>EventLoop</code> 是一个单例的线程池，里面含有一个死循环的线程不断的做着 <code>3</code> 件事情：监听端口，处理端口事件，处理队列事件。每个 <code>EventLoop</code> 都可以绑定多个 <code>Channel</code>，而每个 <code>Channel</code> 始终只能由一个 <code>EventLoop</code> 来处理</p>
<ol start="2">
<li><code>NioEventLoop</code> 的使用 - <code>execute</code> 方法</li>
</ol>
<p>2.1 <code>execute</code> 源码剖析</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_18.png" alt="" loading="lazy"></p>
<p>在 <code>EventLoop</code> 的使用，一般就是 <code>eventloop.execute(task);</code> 看下 <code>execute</code> 方法的实现(在 <code>SingleThreadEventExecutor</code> 类中)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明:
1)首先判断该 <code>EventLoop</code> 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。</p>
<p>2)如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。</p>
<p>3)如果 <code>addTaskWakesUp</code> 是 <code>false</code>，并且任务不是 <code>NonWakeupRunnable</code> 类型的，就尝试唤醒 <code>selector</code>。这个时候，阻塞在 <code>selecor</code>的线程就会立即返回</p>
<p>4)可以下断点来追踪</p>
<p>2.2我们 <code>debugaddTask</code> 和 <code>offerTask</code> 方法源码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.<code>NioEventLoop</code> 的父类 <code>SingleThreadEventExecutor</code> 的 <code>startThread</code> 方法
3.1当执行 <code>execute</code> 方法的时候，如果当前线程不是 <code>EventLoop</code> 所属线程，则尝试启动线程，也就是 <code>startThread</code> 方法，dubug 代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明:该方法首先判断是否启动过了，保证 <code>EventLoop</code> 只有一个线程，如果没有启动过，则尝试使用 <code>Cas</code> 将 <code>state</code> 状态改为 <code>ST_STARTED</code>，也就是已启动。然后调用 <code>doStartThread</code> 方法。如果失败，则进行回滚</p>
<p>看下 <code>doStartThread</code> 方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：
1)首先调用 <code>executor</code> 的 <code>execute</code> 方法，这个 <code>executor</code> 就是在创建 <code>EventLoopGroup</code> 的时候创建的 <code>ThreadPerTaskExecutor</code> 类。该 <code>execute</code> 方法会将 <code>Runnable</code> 包装成 <code>Netty</code> 的 <code>FastThreadLocalThread</code>。</p>
<p>2)任务中，首先判断线程中断状态，然后设置最后一次的执行时间。</p>
<p>3)执行当前 <code>NioEventLoop</code> 的 <code>run</code> 方法，注意：这个方法是个死循环，是整个 <code>EventLoop</code> 的核心</p>
<p>4)在 <code>finally</code> 块中，使用 <code>CAS</code> 不断修改 <code>state</code> 状态，改成 <code>ST_SHUTTING_DOWN</code>。也就是当线程 <code>Loop</code> 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 <code>break</code>。然后，执行 <code>cleanup</code> 操作，更新状态为</p>
<p>5)<code>ST_TERMINATED</code>，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调 <code>terminationFuture</code> 方法。</p>
<p>6)其实最核心的就是 <code>EventLoop</code> 自身的 <code>run</code> 方法。再继续深入 <code>run</code> 方法</p>
<p>4.<code>EventLoop</code> 中的 <code>Loop</code> 是靠 <code>run</code> 实现的，我们分析下 <code>run</code> 方法(该方法在 <code>NioEventLoop</code>)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明:
1)从上面的步骤可以看出，整个 <code>run</code> 方法做了 <code>3</code> 件事情：
<code>select</code> 获取感兴趣的事件。
<code>processSelectedKeys</code> 处理事件。
<code>runAllTasks</code> 执行队列中的任务。</p>
<p>2)上面的三个方法，我们就追一下 <code>select</code> 方法(体现非阻塞)核心 <code>select</code> 方法解析</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selector</code>，防止 <code>selector</code> 阻塞时间过长</p>
<p>5.<code>EventLoop</code> 作为 <code>Netty</code> 的核心的运行机制小结</p>
<p>1)每次执行 <code>execute</code> 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 <code>run</code> 方法，而 <code>run</code> 方法是整个 <code>EventLoop</code> 的核心，就像 <code>EventLoop</code> 的名字一样，<code>LoopLoop</code>，不停的 <code>Loop</code>，<code>Loop</code> 做什么呢？做 <code>3</code> 件事情。</p>
<p>调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selecor</code>，防止 <code>selector</code> 阻塞时间过长。</p>
<p>当 <code>selector</code> 返回的时候，回调用 <code>processSelectedKeys</code> 方法对 <code>selectKey</code> 进行处理。</p>
<p>当 <code>processSelectedKeys</code> 方法执行结束后，则按照 <code>ioRatio</code> 的比例执行 <code>runAllTasks</code> 方法，默认是 <code>IO</code> 任务时间和非 <code>IO</code> 任务时间是相同的，你也可以根据你的应用特点进行调优。比如非 <code>IO</code> 任务比较多，那么你就将</p>
<p><code>ioRatio</code> 调小一点，这样非 <code>IO</code> 任务就能执行的长一点。防止队列积攒过多的任务。</p>
<h2> 10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析</h2>
<h3> 10.8.1 源码剖析目的</h3>
<ol>
<li>在 <code>Netty</code> 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 <code>Netty</code> 对 <code>Socket</code> 的处理速度。</li>
<li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有 <code>2</code> 种方式，而且这 <code>2</code> 种方式实现的区别也蛮大的。</li>
<li>处理耗时业务的第一种方式 -- <code>handler</code> 中加入线程池</li>
<li>处理耗时业务的第二种方式 -- <code>Context</code> 中添加线程池</li>
<li>我们就来分析下两种方式</li>
</ol>
<h3> 10.8.2 源码剖析</h3>
<p>说明 演示两种方式的实现，以及从源码来追踪两种方式执行流程</p>
<ol start="11">
<li>处理耗时业务的第一种方式 -- handler种加入线程池
11.1对前面的 <code>Netty</code> <code>demo</code>源码进行修改，在 <code>EchoServerHandler</code> 的 <code>channelRead</code> 方法进行异步</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：
1)在 <code>channelRead</code> 方法，模拟了一个耗时 <code>10</code> 秒的操作，这里，我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞 <code>Netty</code> 的 <code>IO</code> 线程。</p>
<p>11.2这样处理之后，整个程序的逻辑如图</p>
<p><img src="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_19.png" alt="" loading="lazy"></p>
<p>说明：</p>
<p>1)解释一下上图，当 <code>IO</code> 线程轮询到一个 <code>socket</code> 事件，然后，<code>IO</code> 线程开始处理，当走到耗时 <code>handler</code> 的时候，将耗时任务交给业务线程池。</p>
<p>2)当耗时任务执行完毕再执行 <code>pipeline write</code> 方法的时候，(代码中使用的是 <code>context</code> 的 <code>write</code> 方法，上图画的是执行 <code>pipeline</code> 方法，是一个意思)会将任务这个任务交给 <code>IO</code> 线程</p>
<p>11.3 <code>write</code> 方法的源码(在 <code>AbstractChannelHandlerContext</code> 类)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明:</p>
<p>1)当判定下个 <code>outbound</code> 的 <code>executor</code> 线程不是当前线程的时候，会将当前的工作封装成 <code>task</code>，然后放入 <code>mpsc</code> 队列中，等待 <code>IO</code> 任务执行完毕后执行队列中的任务。</p>
<p>2)这里可以 Debug 来验证(提醒：Debug 时，服务器端 Debug, 客户端 <code>Run</code> 的方式)，当我们使用了 <code>group.submit(new Callable&lt;Object&gt; (){}</code> 在 <code>handler</code> 中加入线程池，就会进入到 <code>safeExecute(executor, task, promise, m);</code> 如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到 <code>safeExecute(executor, task, promise, m);</code>（说明：普通方式执行耗时代码，看我准备好的案例即可）</p>
<p>12.处理耗时业务的第二种方式 -<code>Context</code> 中添加线程池
1.1在添加 <code>pipeline</code> 中的 <code>handler</code> 时候，添加一个线程池</p>
<p>//属性</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p>
<p>1)<code>handler</code> 中的代码就使用普通的方式来处理耗时业务。</p>
<p>2)当我们在调用 <code>addLast</code> 方法添加线程池后，<code>handler</code> 将优先使用这个线程池，如果不添加，将使用 <code>IO</code> 线程</p>
<p>3)当走到 <code>AbstractChannelHandlerContext</code> 的 <code>invokeChannelRead</code> 方法的时候，<code>executor.inEventLoop()</code> 是不会通过的，因为当前线程是 <code>IO</code> 线程 <code>Context</code>（也就是 <code>Handler</code>）的 <code>executor</code> 是业务线程，所以会异步执行，debug 下源码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4)验证时，我们如果去掉 <code>p.addLast(group,newEchoServerHandler());</code> 改成 <code>p.addLastnewEchoServerHandler());</code> 你会发现代码不会进行异步执行。</p>
<p>5)后面的整个流程就变成和第一个方式一样了</p>
<p>13.两种方式的比较</p>
<p>1)第一种方式在 <code>handler</code> 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 <code>mpscTask</code> 中。如果 <code>IO</code> 时间很短，<code>task</code> 很多，可能一个循环下来，都没时间执行整个 <code>task</code>，导致响应时间达不到指标。</p>
<p>2)第二种方式是 <code>Netty</code> 标准方式(即加入到队列)，但是，这么做会将整个 <code>handler</code> 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。</p>
<p>3)各有优劣，从灵活性考虑，第一种较好。</p>
]]></content:encoded>
      <enclosure url="https://javablog-image.oss-cn-hangzhou.aliyuncs.com/blog/chapter10_01.png" type="image/png"/>
    </item>
  </channel>
</rss>