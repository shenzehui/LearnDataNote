import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as s,e as l}from"./app-566117e8.js";const a={},n=l(`<h2 id="rbd-和-aof-机制" tabindex="-1"><a class="header-anchor" href="#rbd-和-aof-机制" aria-hidden="true">#</a> RBD 和 AOF 机制</h2><h3 id="rdb-redis-database" tabindex="-1"><a class="header-anchor" href="#rdb-redis-database" aria-hidden="true">#</a> RDB：Redis DataBase</h3><blockquote><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是 fork 一个子进程，先将数据写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p></blockquote><ul><li>优点：</li></ul><ol><li><p>整个 Redis 数据库将只包含一个文件 dump.rdb，方便持久化。</p></li><li><p>容灾性好，方便备份。</p></li><li><p>性能最大化，fork 子进程来完成写操作，让主操作继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</p></li><li><p>相对于数据集大时，比 AOF 的启动效率更高。</p></li></ol><ul><li>缺点：</li></ul><ol><li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</li><li>由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫米，甚至是 1 秒中。</li></ol><h3 id="aof-append-only-file" tabindex="-1"><a class="header-anchor" href="#aof-append-only-file" aria-hidden="true">#</a> AOF：Append Only File</h3><blockquote><p>以日志的形式记录服务器所处理的每一个写、删除操作，查询记录不会记录，以文本的方式记录，可以打开文件看到详细的操作记录</p></blockquote><ul><li>优点：</li></ul><ol><li>数据安全，Redis 中提供了3种同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是一步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。</li><li>通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof 工具解决数据一致性问题</li><li>AOF 机制的 rewrite 模式。定期对 AOF 文件进行重写，以达到压缩的目的。</li></ol><ul><li>缺点：</li></ul><ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低。</li><li>运行效率没有 RBD 高</li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结：</h3><ol><li><p>AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。</p></li><li><p>AOF 比 RDB 更安全也更大</p></li><li><p>RBD 性能比 AOF好</p></li><li><p>如果两个都配置了，优先加载 AOF 文件</p></li></ol><h2 id="redis-单线程为什么这么快" tabindex="-1"><a class="header-anchor" href="#redis-单线程为什么这么快" aria-hidden="true">#</a> Redis 单线程为什么这么快</h2><p>Redis 基于 Reactor 模式开发了网络事件处理器、文件事件处理器 file event handler。它是单线程的，所以 Redis 才叫做单线程模型，它采用 IO 多路复用机制来监听多个 Socket，根据 Socket 上的事件类型来选择对应的事件处理器来处理这个事件。可以实现高性能的网络通信模型，又可以跟内部其他单线程的模块进行对接，保证了 Redis 内部的线程模型的简单性。</p><p><strong>文件事件处理器</strong>的结构包含4个部分：<code>多个 Socket、IO多路复用程序、文件事件分派器以及事件处理器</code>(命令请求处理器、命令回复处理器、连接应答处理器等)。</p><p>多个 Socket 可能并发的产生不同的事件，IO多路复用程序会监听多个 Socket，会将 <code>Socket</code> 放入一个队列排队，每次，每次从队列中有序、同步取出一个 Socket 给<code>事件分派器</code>，事件分派器把 Socket 给对应的<code>事件处理器</code>。然后一个 Socket 的事件处理完成之后，IO 多路复用程序才会将队列中的下一个 Socket 给事件分派器。文件事件分派器会根据每个 Socket 当期产生的事件，来选择对应的时间处理器来处理。</p><ol><li>Redis 启动初始化时，将连接应答处理器跟 AE_READABLE 事件关联。</li><li>若一个客户端发起连接，会产生一个 AE_READABLE 事件，然后由连接应答处理器负责和客户端建立连接，创建客户端对应的 socket，同时将这个 socket 的 AE_READABLE 事件和命令请求处理器关联，使得客户端可以向主服务器发送命令请求。</li><li>当客户端向 Redis 发请求时(不管读还是写请求)，客户端 socket 都会产生一个 AE_READABLE 事件，触发命令请求处理器，处理器读取客户端的命令内容，然后传给相关程序执行。</li><li>当 Redis 服务器准备好给客户端的响应数据后，会将 socket 的 AE_WRITABLE 事件和命令回复处理器关联，当客户端准备好读取响应数据时，会在 socket 产生一个 AE_WRITABLE 事件，由对应命令回复处理器处理，即将准备好的数据写入 socket，供客户端读取。</li><li>命令回复处理器全部写完到 socket 后，就会删除该 socket 的 AE_WRITABLE 事件和命令回复处理器的映射。</li></ol><p><strong>单线程快的原因：</strong></p><ol><li>纯内存操作(不需要进行 CPU 的切换)</li><li>核心是基于非阻塞 IO 和多路复用机制</li><li>单线程反而避免了多线程的的频繁切换上下文带来的性能问题</li></ol><h2 id="redis-的持久化的机制" tabindex="-1"><a class="header-anchor" href="#redis-的持久化的机制" aria-hidden="true">#</a> Redis 的持久化的机制</h2><h3 id="rdb-redis-database-1" tabindex="-1"><a class="header-anchor" href="#rdb-redis-database-1" aria-hidden="true">#</a> RDB：Redis DataBase</h3><blockquote><p>将某一个时刻的内存快照(Snapshot)，以二进制的方式写入磁盘。</p></blockquote><p><strong>手动触发：</strong></p><ul><li>save 命令，使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用</li><li>bgsave 命令，fork 出一个子进程执行持久化，主进程只在 fork 过程中有短暂的阻塞，主进程就可以响应客户端请求了</li></ul><p><strong>自动触发：</strong></p><ul><li>save m n：在 m 秒内，如果有 n 个键发生改变，则自动触发持久化，通过 bgsave 执行，如果设置多个、只要满足其一就会触发，配置文件有默认配置(可以注释调掉)</li><li>flushall：用于清空 redis 所有的数据库，flushdb 清空当期 redis 所在库数据(默认是 0 号数据库)，会清空 RDB 文件，同时也会生成 dump.rdb，内容为空</li><li>主从同步：全量同步时会自动触发 bgsave 命令，生成 rdb 发送给从节点</li></ul><p><strong>优点：</strong></p><ol><li><p>整个 Redis 数据库将只包含一个文件 dump.rdb，方便持久化。</p></li><li><p>容灾性好，方便备份。</p></li><li><p>性能最大化，fork 子进程来完成写操作，让主操作继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</p></li><li><p>相对于数据集大时，比 AOF 的启动效率更高。</p></li></ol><p><strong>缺点：</strong></p><ol><li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</li><li>由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫米，甚至是 1 秒中，会占用 cpu。</li></ol><h3 id="aof-append-only-file-1" tabindex="-1"><a class="header-anchor" href="#aof-append-only-file-1" aria-hidden="true">#</a> AOF：Append Only File</h3><blockquote><p>以日志的形式记录服务器所处理的每一个写、删除操作，查询记录不会记录，以文本的方式记录，可以打开文件看到详细的操作记录，调操作系统命令进程刷盘</p></blockquote><ol><li>所有的写命令会追加到 AOF 缓冲中。</li><li>AOF 缓冲区根据对应的策略向硬盘进行同步操作</li><li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li><li>当 Redis 重启时，可以加载 AOF 文件进行数据恢复</li></ol><p><strong>同步策略：</strong></p><ul><li>每秒同步：异步完成，效率非常高，一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。</li><li>每修改同步：同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢一条</li><li>不同步：由操作系统控制，可能丢失较多数据</li></ul><p><strong>优点：</strong></p><ol><li>数据安全</li><li>通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof 工具解决一致性问题。</li><li>AOF 机制的 rewrite 模式。定期对 AOF 文件进行重写，已达到压缩的目的</li></ol><p><strong>缺点：</strong></p><ol><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 rdb 启动效率低。</li><li>运行效率没有 RBD 高</li></ol><p>AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。</p><p>AOF 比 RDB 更安全也更大</p><p>RBD 性能比 AOF好</p><p>如果两个都配置了，优先加载 AOF 文件</p><h2 id="redis-的过期键的删除策略" tabindex="-1"><a class="header-anchor" href="#redis-的过期键的删除策略" aria-hidden="true">#</a> Redis 的过期键的删除策略</h2><p>Redis 是 key-value 数据库，我们可以设置 Redis 中缓存的 key 的过期时间。Redis 的过期策略就是指定当 Redis 中缓存的 key 过期了，Redis 如何处理。</p><ul><li>惰性过期：只有当访问一个 key 时，才会判断 key 是否已过期，过期则删除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的 key 没有再次被访问，从而不会被清除，占用大量内存。</li><li>定期过期：每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和 内存资源达到最优的平衡效果。</li></ul><p>(expries 字典会保存所有设置了过期时间的 key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis 集群中保存的所有键。)</p><p>Redis 中同时使用了惰性过期和定期过期两种过期策略。</p><h2 id="redis-分布式锁底层是如何实现的" tabindex="-1"><a class="header-anchor" href="#redis-分布式锁底层是如何实现的" aria-hidden="true">#</a> Redis 分布式锁底层是如何实现的？</h2><ol><li>首先利用 setnx 来保证：如果 key 不存在才能获取到锁，如果 key 存在，则获取不到锁</li><li>然后还要利用 lua 脚本来保证多个 redis 操作的原子性</li><li>同时还要考虑到锁过期，所以需要额外的一个看门狗定时任务来监听锁是否需要续约</li><li>同时还要考虑到 redis 节点挂掉之后的情况，所以需要采用红锁的方式来同时向 N/2 +1 个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个 redis 节点挂掉了，锁也不会被其他客户端获取到。</li></ol><h2 id="redis-有哪些数据结构-分别有哪些典型的应用场景" tabindex="-1"><a class="header-anchor" href="#redis-有哪些数据结构-分别有哪些典型的应用场景" aria-hidden="true">#</a> Redis 有哪些数据结构？分别有哪些典型的应用场景？</h2><p>Redis 的数据结构有：</p><ol><li>字符串：可以用来做简单的数据，可以缓存某个简单的字符串，也可以缓存某个 json 格式的字符串，Redis 分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session 共享、分布式 ID</li><li>哈希表：可以用来存储一些 key-value 对，更适合用来存储对象</li><li>列表：Redis 的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据</li><li>集合：和列表相似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集等操作，从而可以实现类似我和某人共同关注的人、朋友圈点赞等功能</li><li>有序集合：集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能</li></ol><h2 id="redis-主从复制的核心原理" tabindex="-1"><a class="header-anchor" href="#redis-主从复制的核心原理" aria-hidden="true">#</a> Redis 主从复制的核心原理</h2><p>通过执行 salveof 命令设置 slaveof 选项，让一个服务器去复制另一个服务器的数据。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。</p><p><strong>全量复制：</strong></p><p>(1) 主节点通过 bgsave 命令 fork 子进程进行 RDB 持久化(生成全量数据快照)，该过程非常消耗 CPU、内存(页表复制)、硬盘 IO等</p><p>(2) 主节点通过网络将 RDB 文件发送给从节点，对主从节点的贷款都会带来很大的消耗</p><p>(3) 从节点清空老数据、载入新 RDB 文件的过程是阻塞的，无法响应客户端；如果从节点执行 bgrewriteof，也会带来额外的消耗</p><p><strong>部分复制：</strong></p><ul><li>复制偏移量：执行复制的双方，主从节点，分别会维护一个复制偏移量 offset</li><li>复制积压缓冲区：<strong>主节点内部维护了一个固定长度的、先进先出(FIFO)队列</strong>作为复制积压缓冲区，当主从节点 offset 的差距过大超过缓冲区的长度时，将无法执行部分复制，只能执行全量复制。</li><li>服务器运行 ID(runid)：每个 Redis 节点，都有其运行 ID，运行 ID 由节点在启动时自动生成，主节点会将自己的运行 ID 发送给从节点，从节点会将主节点的运行 ID 存起来。从节点 Redis 断开重连的时候，就是根据运行 ID 来判断同步的进度： <ul><li>如果从节点保存的 runid 与 主节点现在的 runid 相同，说明主从节点之前同步过，主节点会继续尝试使用使用部分复制(到底能不能部分复制还要看 offset 和复制积压缓冲区的情况)；</li><li>如果从节点保存的 runid 与主节点现在的 runid 不同，说明从节点在断线前同步的 Redis 节点并不是当前的主节点，只能进行全量复制。</li></ul></li></ul><p>过程原理：</p><p><img src="https://s1.vika.cn/space/2022/11/21/798caba8d1f442009d953f5c3227ff9e" alt="image-20221112190247115" loading="lazy"></p><h2 id="布隆过滤器原理-优缺点" tabindex="-1"><a class="header-anchor" href="#布隆过滤器原理-优缺点" aria-hidden="true">#</a> 布隆过滤器原理，优缺点</h2><p>位图：int[10]，每个 int 类型的整数是 4*8 = 32 个 bit，则 int[10] 一共有 320 bit，每个 bit 非0 即 1，初始化时都是 0。添加数据时，将数据进行 hash 得到 hash 值，对应到 bit 为，将 bit 改为 1，hash 函数可以定义多个，则一个数据添加将多个(hash 函数个数)bit 改为 1，多个 hash 函数的目的是减少 hash 碰撞的概率</p><p><img src="https://s1.vika.cn/space/2022/11/21/cb6451e771b149429d254031296a20cc" alt="" loading="lazy"></p><p>查询数据：hash 函数计算得到 hash 值，对应到 bit 中，如果有一个为 0，则说明数据不在 bit 中，如果都为 1，则该数据可能在 bit 中</p><p><img src="https://s1.vika.cn/space/2022/11/21/d63b39a7809d43a8b662b9493d55e74a" alt="img" loading="lazy"></p><p><strong>优点：</strong></p><ul><li>占用内存小</li><li>增加和查询元素的时间复杂度为：O(K)，(K为哈希函数的个数，一般比较小)，与数据量大小无关</li><li>哈希函数互相之间没有关系，方便硬件并行计算</li><li>布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势</li><li>数据量大时，布隆过滤器可以表示全集</li><li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</li></ul><p><strong>缺点：</strong></p><ul><li>误判率，即存在假阳性(False Position)，不能准确判断元素是否在集合中</li><li>不能获取元素本身</li><li>一般情况下不能从布隆过滤器中删除元素</li></ul><h2 id="什么是-redis-为什么用-redis" tabindex="-1"><a class="header-anchor" href="#什么是-redis-为什么用-redis" aria-hidden="true">#</a> 什么是 Redis，为什么用 Redis？</h2><p>Redis 是一种支持 key-value 等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p><ul><li><strong>读写性能优异</strong><ul><li>Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s</li></ul></li><li><strong>数据类型丰富</strong><ul><li>Redis 支持二进制案例的 Strings，Lists，Hashes，Sets 及 Ordered Sets 数据类型凑哦。</li></ul></li><li><strong>原子性</strong><ul><li>Redis 的所有操作都是原子性的，同时 Redsi 还支持对几个操作全并后的原子性操作。</li></ul></li><li><strong>丰富的特性</strong><ul><li>Redis 支持 publish/subscribe，通知，key 过期等特性</li></ul></li><li><strong>持久化</strong><ul><li>Redis 支持 RDB，AOF 等持久化方式</li></ul></li><li><strong>发布订阅</strong><ul><li>Redis 支持发布/订阅模式</li></ul></li><li><strong>分布式</strong><ul><li>Redis Cluster</li></ul></li></ul><h2 id="为什么redis-是单线程的以及为什么这么快" tabindex="-1"><a class="header-anchor" href="#为什么redis-是单线程的以及为什么这么快" aria-hidden="true">#</a> 为什么Redis 是单线程的以及为什么这么快？</h2><ul><li>redis 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速</li><li>数据结构简单，对数据操作也简单，redis 中的数据结构是专门进行设计的</li><li>采用单线程模型，避免了不必要的上下文切换和竞争条件，也不存在多线程或者多线程切换而消耗 CPU，不用考虑各种锁的问题，不存在加锁，释放锁的操作，没有因为可能出现死锁而导致性能消耗</li><li>使用了多路 IO 复用模型，非阻塞 IO</li><li>使用底层模型不同，它们之间底层实现方式及与客户端之间的，通信的应用协议不一样，Redis 直接构建了自己的 VM 机制，因为一般的系统调用函数的话，会浪费一定的时间去移动和请求</li></ul><h2 id="redis-一般有哪些使用场景" tabindex="-1"><a class="header-anchor" href="#redis-一般有哪些使用场景" aria-hidden="true">#</a> Redis 一般有哪些使用场景</h2><p>可以结合自己的项目讲讲，比如</p><ul><li><strong>热点数据的缓存</strong></li></ul><p>缓存是 Redis 最常见的应用场景，之所以这么使用，主要是因为 Redis 读写性能优越，而且逐渐有取代 memcached，成为首选服务端缓存的组件。而且，Redis 内部是支持事务的，在使用的时候能有效保证数据的一致性。</p><ul><li><strong>限时业务的应用</strong></li></ul><p>redis 中可以使用 expire 命令设置一个键的生存时间，到时间后 redis 会删除它。利用这一特性可以运用显示的优惠活动信息、手机验证码等业务场景。</p><ul><li><strong>计数器相关问题</strong></li></ul><p>redis 由于 incrby 命令可以实现原子性的递增，所以可以运用高并发的秒杀活动、分布式序列号的生产、具体业务还体现在比如限制一个手机号发多少短信，一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p><ul><li><strong>分布式锁</strong></li></ul><p>这个主要利用 redis 的 setnx 命令进行，setnx：&quot;set if not exists&quot; 就是如果不存在则成功设置缓存同时返回1，否则返回0，这个特性在 XXX 后台中有所应用，因为我们的服务器是集群的，定时任务可能在两台机器上都会进行，所以在定义任务中首先通过 sestnx 设置一个 lock，如果成功设置则执行，如果没有设置成功，则表明该定时任务已执行。当然结合具体业务，我们可以给这个 lock 加一个过期时间，比如说 30 分钟执行一次定义任务，那么这个过期时间设置小于 30 分钟的一个时间就可以，这个与定义任务的周期以及定时任务执行消耗时间有关。</p><p>在分布式锁的场景中，主要用在比如秒杀系统等。</p><h2 id="redis-有哪些数据类型" tabindex="-1"><a class="header-anchor" href="#redis-有哪些数据类型" aria-hidden="true">#</a> Redis 有哪些数据类型？</h2><ul><li><strong>5种基础数据类型</strong>，分别是：String、List、Set、Zset、Hash。</li></ul><p><img src="https://s1.vika.cn/space/2022/11/21/309fdcb4fa144dd6a260d5c5ecf32d49" alt="" loading="lazy"></p><p><img src="https://s1.vika.cn/space/2022/11/21/ead9d96fb248413eb8d3d107957eaf73" alt="image-20221121080935987" loading="lazy"></p><ul><li><strong>三种特殊的数据类型</strong> 分别是 HyperLogLogs(基数统计)，Bitmaps(位图) 和 geospatial (地理位置)</li></ul><h2 id="谈谈-redis-的对象机制-redisobject" tabindex="-1"><a class="header-anchor" href="#谈谈-redis-的对象机制-redisobject" aria-hidden="true">#</a> 谈谈 Redis 的对象机制 (redisObject)?</h2><p>比如说，集合类型就可以由字典和整数集合两种不同的数据结构实现，但是，当用户执行 ZADD 命令时，用户应该不必关心集合使用的是什么编码，只要 Redis 能按照 ZADD 命令的指令，将新元素添加到集合就可以了。</p><p>这说明，<strong>操作数据类型的命令处理要对键的类型进行检查之外，还需要根据数据类型的不同编码进行多态处理</strong></p><p>为了解决以上问题，<strong>Redis 构建了自己的类型系统</strong>，这个系统的主要功能包括：</p><ul><li>redisObject 对象</li><li>基于 redisObject 对象的类型检查</li><li>基于 redisObject 对象的显式多态函数</li><li>对 redisObject 进行分配、共享和销毁机制</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">/*
 * Redis 对象
 */</span>
typedef struct redisObject <span class="token punctuation">{</span>
    <span class="token comment">// 类型</span>
    unsigned type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token comment">// 编码方式</span>
    unsigned encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token comment">// LRU - 24位, 记录最末一次访问时间(相对于lru_clock); 或者 LFU(最少使用的数据：8位频率，16位访问时间)</span>
    unsigned lru<span class="token operator">:</span><span class="token constant">LRU_BITS</span><span class="token punctuation">;</span> <span class="token comment">// LRU_BITS: 24</span>

    <span class="token comment">// 引用计数</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>

    <span class="token comment">// 指向底层数据结构实例</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>

<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图对应上面的结构</p><p><img src="https://s1.vika.cn/space/2022/11/21/af4f1544690240189992fc11cde6178d" alt="image-20221121081224103" loading="lazy"></p><h2 id="redis-数据类型有哪些底层数据结构" tabindex="-1"><a class="header-anchor" href="#redis-数据类型有哪些底层数据结构" aria-hidden="true">#</a> Redis 数据类型有哪些底层数据结构？</h2><p><img src="https://s1.vika.cn/space/2022/11/21/309fdcb4fa144dd6a260d5c5ecf32d49" alt="" loading="lazy"></p><ul><li>简单动态字符串 - sds</li><li>压缩列表 - ZipList</li><li>快表 - QuickList</li><li>字典/哈希表 - Dict</li><li>整数集 - IntSet</li><li>跳表 - ZSkipList</li></ul><h2 id="为什么要设计sds" tabindex="-1"><a class="header-anchor" href="#为什么要设计sds" aria-hidden="true">#</a> 为什么要设计sds？</h2><ul><li><strong>常数复杂度获取字符串长度</strong></li></ul><p>由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 <code>strlen key</code> 命令可以获取 key 的字符串长度。</p><ul><li><strong>杜绝缓冲区溢出</strong></li></ul><p>我们知道在 C 语言中使用 <code>strcat</code> 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，<strong>会首先根据记录的 len 属性检查内存空间是否满足需求</strong>，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p><ul><li><strong>减少修改字符串的内存重新分配次数</strong></li></ul><p>C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存(先释放再申请)，因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。</p><p>而对于SDS，由于<code>len</code>属性和<code>alloc</code>属性的存在，对于修改字符串SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种策略：</p><ol><li><strong>空间预分配</strong>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。</li><li><strong>惰性空间释放</strong>：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。(当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。)</li></ol><ul><li><strong>二进制安全</strong></li></ul><p>因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件(如图片等)，内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 <code>buf</code> 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p><ul><li><strong>兼容部分 C 字符串函数</strong></li></ul><p>虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<code>&lt;string.h&gt;</code> 中的一部分函数。</p><h2 id="redis-一个字符串类型的值能存储最大容量是多少" tabindex="-1"><a class="header-anchor" href="#redis-一个字符串类型的值能存储最大容量是多少" aria-hidden="true">#</a> Redis 一个字符串类型的值能存储最大容量是多少？</h2><p><strong>512M</strong></p><h2 id="为什么会设计-stream" tabindex="-1"><a class="header-anchor" href="#为什么会设计-stream" aria-hidden="true">#</a> 为什么会设计 Stream？</h2><p>用过 Redis 做消息队列的都了解，基于 Redis 的消息队列实现有很多种，例如：</p><ul><li><strong>PUB/SUB，订阅/发布模式</strong><ul><li>但是发布订阅模式是无法持久化的，如果出现网络断开，Redis 宕机等，消息就会被丢弃；</li></ul></li><li>基于 Lsit LPUSH + BRPOP 或者 <strong>基于 Sorted-Set</strong> 的实现</li></ul><p><strong>消息组消费图</strong></p><p><img src="https://s1.vika.cn/space/2022/11/21/6c60020b8d424d40bb7b399f84b17e7a" alt="image-20221121081147625" loading="lazy"></p><h2 id="redis-stream用在什么样场景" tabindex="-1"><a class="header-anchor" href="#redis-stream用在什么样场景" aria-hidden="true">#</a> Redis Stream用在什么样场景？</h2><h2 id="公众号" tabindex="-1"><a class="header-anchor" href="#公众号" aria-hidden="true">#</a> 公众号</h2><p><img src="https://s1.vika.cn/space/2022/12/01/f1f467dd3b8e4984a50dce782aa346ff" alt="" loading="lazy"></p>`,130),d=[n];function r(t,o){return e(),s("div",null,d)}const h=i(a,[["render",r],["__file","redis.html.vue"]]);export{h as default};
