import{_ as l}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as s,c as n,e as i}from"./app.3d24f990.js";const a={},e=i(`<h2 id="acid-靠什么保证的" tabindex="-1"><a class="header-anchor" href="#acid-靠什么保证的" aria-hidden="true">#</a> ACID 靠什么保证的？</h2><p>A 原子性，由 undo log 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql</p><p>C 一致性，有其他三大特征保证、程序代码要保持业务上的一致性</p><p>I 隔离性，由 MVCC 来保证</p><p>D 持久性，由<code>内存 + redo log</code> 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，宕机的时候可以从 redo log 恢复</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">InnoDB</span> redo log 写盘<span class="token punctuation">,</span><span class="token keyword">InnoDB</span> 事务进入 <span class="token keyword">prepare</span> 状态。
如果前面 <span class="token keyword">prepare</span> 成功<span class="token punctuation">,</span>binlog 写盘<span class="token punctuation">,</span>再继续将事务日志持久化到 binlog<span class="token punctuation">,</span>如果持久化成功<span class="token punctuation">,</span>那么 <span class="token keyword">InnoDB</span> 事务则进入 <span class="token keyword">commit</span> 状态<span class="token punctuation">(</span>在 redo log 里面写一个 <span class="token keyword">commit</span> 记录<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>redolog 的刷盘会在系统空闲时进行</p><h2 id="b-树和-b-数的区别-为什么-mysql-使用-b-树" tabindex="-1"><a class="header-anchor" href="#b-树和-b-数的区别-为什么-mysql-使用-b-树" aria-hidden="true">#</a> B 树和 B+ 数的区别，为什么 Mysql 使用 B+ 树？</h2><p>B 树的特点：</p><ol><li>节点排序</li><li>一个节点可以存多个元素，多个元素也排序了</li></ol><p>B+ 树的特点：</p><ol><li>拥有 B 树的特点</li><li>叶子节点之间有指针</li><li>非叶子节点上的元素在叶子节点都冗余了，也就是叶子节点中存储了所有元素，并且排好顺序</li></ol><p>Mysql 索引使用的是 B+ 树，因为索引是用来加快查询的，而 B+ 数通过对数据进行排序所以是可以通过查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得 B+ 树的高度不会太高，在 Mysql 中一个 Innodb 页就是一个 B+ 树节点，一个 Innodb 页默认 16kb，所以一般情况下一颗两层 B+ 树可以存 2000万行左右的数据，然后通过利用 B+ 树叶子节点存储了所有数据并进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等 SQL 语句。</p><h2 id="mysql-索引结构是怎么样的-聚簇索引和非聚簇索引又是什么" tabindex="-1"><a class="header-anchor" href="#mysql-索引结构是怎么样的-聚簇索引和非聚簇索引又是什么" aria-hidden="true">#</a> Mysql 索引结构是怎么样的？聚簇索引和非聚簇索引又是什么？</h2><p>二叉树 —&gt; AVL 平衡数 —&gt; 红黑树 —&gt; B-树 —&gt; B+ 树</p><p>二叉树：每个节点最多只有两个子节点，左边的子节点都比当前节点小，右边的子节点都比当前节点大。</p><p>AVL 平衡树：树中任意节点的两个子树的高度差最大为 1</p><p>红黑树：</p><ol><li>每个节点都是红色或者黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点。</li><li>红色节点的父子节点都必须是褐色。</li><li>从任一节点到其每个叶子的所有路径都包含相同的黑色节点</li></ol><p>B-树 ：</p><ol><li>B-树的每个非叶子结点的子节点个数都不会超过 D(这个 D 就是 B-树的阶)</li><li>所有的叶子节点都在同一层。</li><li>所有节点关键字都是按照递增顺序来排列。</li></ol><p>B+树</p><ol><li>非叶子节点不存储数据，只进行数据索引。</li><li>所有数据都存储在叶子节点当中。</li><li>每个叶子节点都存有相邻叶子节点的指针。</li><li>叶子节点按照本身关键字从小到大排序。</li></ol><p><strong>聚簇索引就是数据和索引是在一起的，而非聚簇索引就是数据和索引不在一起</strong></p><p>MyISAM 使用的是非聚簇索引，树的子节点上的 data 不是数据本身，而是数据存放的地址。InnoDB 采用的是聚簇索引，树的叶子节点上的 data 就是数据本身。</p><p>聚簇索引的数据物理存放顺序和索引顺序是一致的，所以一个表当中只能有一个聚簇索引，而非聚簇索引可以有多个。</p><p>InnoDB 中，如果表定义了 PK，那么 PK 就是聚簇索引。如果没有 PK，就会找第一个非空的 unique 列作为聚簇索引。否则，InnoDB 会创建一个 隐藏的 row-id 作为聚簇索引。</p><p>Mysql 的覆盖索引和回表</p><ul><li>如果只需要在一颗索引树上就可以获取 SQL 上所需的所有列，就不需要再回表查询，这样查询速度就可以更快。</li><li>实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中 。</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">user</span><span class="token punctuation">(</span>PK id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>sex<span class="token punctuation">)</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span>  —<span class="token operator">&gt;</span> 在 name 字段上建立一个索引。
<span class="token keyword">select</span> id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>sex <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span>  —<span class="token operator">&gt;</span> 将 name 上的索引升级成为 <span class="token punctuation">(</span>name<span class="token punctuation">,</span>sex<span class="token punctuation">)</span>的联合索引
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="innodb-是如何实现事务的" tabindex="-1"><a class="header-anchor" href="#innodb-是如何实现事务的" aria-hidden="true">#</a> Innodb 是如何实现事务的？</h2><p>Innodb 通过 Buffer Pool，LogBuffer，Redo Log，Undo Log 来实现事务，以一个 upload 语句为例：</p><ol><li>Innodb 在收到一个 update 语句后，会先根据条件找到数据所在页，并将该页缓存在 Buffer Pool 中</li><li>执行 update 语句，修改 Buffer Pool 中的数据，也就是内存中的数据</li><li>针对 update 语句生成一个 RedoLog 对象，并存入 LogBuffer 中</li><li>针对 update 语句生成 undoLog 日志，用于事务回滚</li><li>如果事务提交，那么则把 RedoLog 对象进行持久化，后续还有其他机制将 Buffer Pool 中所修改的数据页持久化到磁盘中</li><li>如果事务回滚，则利用 undoLog 日志进行回滚</li></ol><h2 id="mysql-索引的数据结构-各自优劣" tabindex="-1"><a class="header-anchor" href="#mysql-索引的数据结构-各自优劣" aria-hidden="true">#</a> Mysql 索引的数据结构，各自优劣</h2><p>索引的数据结构和具体索引引擎的实现相关，在 Mysql 中使用较多的索引有 Hash 索引，B+树索引等，**InnoDB 存储引擎的默认索引实现为：B+树索引。**对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单表记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择B树索引</p><p><strong>B+树索引：</strong></p><p>B+树是一个平衡多叉树，从根节点到每个叶子节点的高度值不超过1，而且同层级的节点间有指针互相链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。</p><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/9ae2d6fb0ec7b2fb87a7c428e266acad.png" alt="" loading="lazy"></p><p><strong>哈希索引：</strong></p><p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到了叶子节点逐级查找，只需要一次哈希算法即可立即定位到响应的位置，速度非常快</p><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/2352266-20210710151708167-1675912757.png" alt="" loading="lazy"></p><ul><li><p>keys：代表创建索引的列值；</p></li><li><p>buckets： 就是计算出来的hash值和对应的数据的物理位置组成的hash表；</p></li><li><p>entries：就是代表具体的数据行；</p></li></ul><p>创建hash索引后，会为每个键值通过特定的算法计算出一个哈希码(hash code)，需要注意的是不同的键值计算出来的hash值可能是相同的，例上图上的 John Smith 和 Sandra Dee 算出来的hash值都是152，然后找到 hash 值为152在hash表中的存储数据的物理位置，这个位置对应着两条数据也(就是 John Smith 521-1234 和 Sandra Dee 521-9655)，然后再次遍历这两条数据，找到需要的数据，这就解释了为啥 hash 冲突严重了。</p><p>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提是键值都是唯一的。如果键值不是唯一的，就需要找到该键所在位置，然后再根据链表往后扫描，直到找到响应的数据。</p><p>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能不连续了，就没办法再利用索引完成范围查询检索。</p><p>哈希索引也没办法利用索引完成排序，以及 like &#39;xxx%&#39; 这样的部分模糊查询(这种部分模糊查询，其实本质也是范围查询)；</p><p>哈希索引也不支持多级联合索引的最左匹配规则；</p><p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。</p><h2 id="mysql-的集群如何搭建的-读写分离是怎么做的" tabindex="-1"><a class="header-anchor" href="#mysql-的集群如何搭建的-读写分离是怎么做的" aria-hidden="true">#</a> Mysql 的集群如何搭建的？读写分离是怎么做的？</h2><p>Mysql 主从集群的搭建原理：</p><ol><li><p>master 将操作语句记录到 binlog (记录的是每一步的数据操作)日志中</p></li><li><p>salve 服务器会在一定时间间隔内对 master 二进制日志进行探测其是否发生改变，如果发生改变</p></li><li><p>salve 开启两个线程：IO 线程和 SQL 线程</p><ul><li><p>IO 线程：负责读取 master 的 binlog 内容到中继日志 relay log 里</p></li><li><p>SQL 线程：负责从 relay log 日志里读出 binlog 内容，并更新到 slave 的数据库里(保证数据一致)</p></li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/1080958-20190716114159060-648770948.png" alt="" loading="lazy"></p><p>MySQL 通过将主节点的 Binlog 同步给节点完成主从之间的数据同步。</p><p>MySQL 的主从集群只会将 binlog 从主节点到从节点，而不会反过来同步。由此也就引申出了读写分离的问题。</p><p><strong>因为要保证主从之间的数据一致，写数据的操作只能在主节点完成。而读数据的操作，可以在主节点或者从节点上完成。</strong></p><h2 id="mysql-执行计划怎么看" tabindex="-1"><a class="header-anchor" href="#mysql-执行计划怎么看" aria-hidden="true">#</a> Mysql 执行计划怎么看？</h2><p><strong>执行计划就是 sql 的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数</strong></p><p>EXPLAIN SELECT * from A where X=? and Y=?</p><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/image-20221112123752976.png" alt="image-20221112123752976" loading="lazy"></p><ol><li>id：是一个有顺序的编号，是查询的顺序号，有几个 select 就是显示几行，id 的顺序是按 select 出现的顺序增长的。id 列的值越大执行优先级越高越先执行，id 列的值相同则从上往下执行，id 列的值为 NULL 最后执行。</li><li>selectType 表示查询中每个 select 子句的类型 <ul><li>SIMPLE：表示此查询不包含 UNION 查询或子查询</li><li>PRIMARY：表示此查询的最外层的查询(包含子查询)</li><li>SUBQUERY：子查询中的第一个 SELECT</li><li>UNION：表示此查询是 UNION 的第二或随后的查询</li><li>DEPENENT UNION：UNION 中的第二个或后面的查询语句，取决于外面的查询</li><li>UNION RESULT，UNION 的结果</li><li>DEPENDENT SUBQUERY：子查询的第一个 SELECT，取决于外面的查询，即子查询依赖于外层查询的结果</li><li>DERIVER：衍生，表示导出表的 SELECT(FROM 子句的子查询)</li></ul></li><li>table：表示该语句查询的表</li><li>**type：**优化 sql 的重要字段，也是我们判断 sql 性能的优化程度重要指标，他的取值类型范围： <ul><li>const：通过索引一次命中，匹配一行数据</li><li>system：表中只有一行数据，相当于系统表(效率优于 const)</li><li>eq_ref：唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配</li><li>ref：非唯一性索引扫描，返回匹配某个值的所有</li><li>range：只检索给定范围的行，使用一个索引来选择行，一般用 between、&lt;、&gt;；</li><li>index：只遍历索引树；</li><li>ALL：表示全表扫描，这个类型的查询是性能最差的查询之一。那么基本就是随着表的数量增多，执行效率越慢。(没有走索引)</li></ul></li></ol><p><strong>执行效率：</strong></p><p><strong>ALL &lt; index &lt; range &lt; ref &lt; eq_ref &lt; const &lt; system。最好是避免 ALL 和 index</strong></p><ol start="5"><li>possible_keys：它表示 Mysql 在执行该 sql 语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。</li><li>key：此字段是 mysql 在当前查询时所真正使用到的索引，它是 possible_keys 的子集</li><li>key_len：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是我们优化 sql 时，评估索引的重要指标。</li><li>rows：mysql 查询优化器根据统计信息，估算该 sql 返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大</li><li>filtered：返回结果的行占需要读取的行(rows 列的值)的百分比，就是百分比越高，说明需要查询到数据越准确，百分比越小，说明查询到的数据量大，而结果集很少</li><li>extra <ul><li>using filesort：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果，一般有 using filesort 都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。</li><li>using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。</li><li>using temporary：查询有使用临时表，一般出现于排序，分组和多表 join 的情况，查询效率不高，建议优化。</li><li>using where：sql 使用了 where 过滤，效率较高</li></ul></li></ol><h2 id="mysql-主从同步原理" tabindex="-1"><a class="header-anchor" href="#mysql-主从同步原理" aria-hidden="true">#</a> Mysql 主从同步原理</h2><p>Mysql 主从同步的过程：</p><p>Mysql 的主从复制中主要有三个线程：<code>master(binlog dump thread)、slave(I/O thread、SQL thread)</code>，Master 一条线程和 Slave 中的两条线程。</p><ul><li>主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务器启动那一刻起，保存所有修改数据库结构或内容的一个文件。</li><li>主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。</li><li>从节点 I/O 线程接收 binlog 内容，并将其先入 relay log(中继日志) 文件中。</li><li>从节点的 SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。</li></ul><p>注：主从节点使用 binlog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。</p><p>由于 mysql 默认的复制方式是异步的，主库把日志发送给从库后不关系从库是否已经处理，这样产生一个问题就是假设主库挂了，从库处理失败，这时候从库升为主库后，日志就丢失了。由此产生两个概念：</p><p><strong>全同步复制</strong></p><p>主库写入 binlog 后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。</p><p><strong>半同步复制</strong></p><p>和全同步不同的是，半同步赋值的逻辑是这样的，从库写入日志成功后返回 ACK 确认给主库，主库收到至少一个从库的确认就认为写操作完成。</p><h2 id="mysql-有哪几种数据存储引擎-有什么区别" tabindex="-1"><a class="header-anchor" href="#mysql-有哪几种数据存储引擎-有什么区别" aria-hidden="true">#</a> Mysql 有哪几种数据存储引擎？有什么区别？</h2><p>MySQL 通过 show ENGINES 指令可以看到所有支持的数据库存储引擎。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> ENGINES
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/image-20221112132846604.png" alt="" loading="lazy"></p><p>其中最为常用的是 <code>MyISAM</code> 和 <code>InnoDB</code></p><p>MyISAM 和 InnoDB 的区别：</p><ol><li>存储文件。MyISAM 每个表有两个文件，MYD 和 MYISAM 文件。其中，MYD 是数据文件，MyISAM 是索引文件。而 InnoDB 每个表只有一个文件：ibd。</li><li>InnoDB 支持事务，支持行级锁，支持外键。</li><li>InnoDB 支持 XA 事务</li><li>InnoDB 支持 Savepoints：部分回滚</li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>XA <span class="token keyword">START</span> <span class="token string">&#39;test&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
XA <span class="token keyword">END</span> <span class="token string">&#39;test&#39;</span><span class="token punctuation">;</span>
XA <span class="token keyword">PREPARE</span> <span class="token string">&#39;test&#39;</span><span class="token punctuation">;</span>
XA <span class="token keyword">COMMIT</span> <span class="token string">&#39;test&#39;</span>
XA <span class="token keyword">ROLLBACK</span> <span class="token string">&#39;test&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="简述-mysql-中索引类型及对数据库的性能的影响" tabindex="-1"><a class="header-anchor" href="#简述-mysql-中索引类型及对数据库的性能的影响" aria-hidden="true">#</a> 简述 Mysql 中索引类型及对数据库的性能的影响</h2><p>普通索引：允许被索引的数据列包含重复的值。</p><p>唯一索引：可以保证数据记录的唯一性。</p><p>主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。</p><p>联合索引：索引可以覆盖多个数据列，如像 INDEX(colunmA，columnB)索引。</p><p>全文索引：通过建立 <code>倒排索引</code>，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术，可以通过 ALTER TABLE table_name ADD FULLTEXT(column)创建全文索引</p><p>索引可以极大的提高数据的查询速度</p><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p>但是会降低插入、删除、更新表的速度，因为在执行这些操作时，还要操作索引文件</p><p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果需要建立聚簇索引，那么需要的空间就会更大，如果非聚簇索引很多，一旦聚簇索引改变，那么所有非聚簇索引都会跟着变。</p><h2 id="能说下-myisam-和-innodb-的区别吗" tabindex="-1"><a class="header-anchor" href="#能说下-myisam-和-innodb-的区别吗" aria-hidden="true">#</a> 能说下 myisam 和 innodb 的区别吗？</h2><p>myisam 引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于大量查询少量插入的场景来使用，而且 myisam 不支持外键，并且索引和数据是分开存储的。</p><p>innodb 是基于 B+Tree 索引来建立的，和 myisam 相反，它支持事务、外键，并且通过 MVCC(多版本并发控制) 来支持高并发，索引和存储数据是一起的。</p><h2 id="说下-mysql-索引有哪些吧" tabindex="-1"><a class="header-anchor" href="#说下-mysql-索引有哪些吧" aria-hidden="true">#</a> 说下 MySQL 索引有哪些吧？</h2><p>索引在什么层面？</p><p>首先，索引是在<strong>存储引擎层实现</strong>的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现</p><p>有哪些？</p><ul><li><strong>B+Tree 索引</strong></li></ul><p>是大多数 MySQL 存储引擎的默认索引类型。</p><ul><li><strong>哈希索引</strong><ul><li>哈希索引能以 O(1) 时间进行查找，但是失去了有序性；</li><li>innoDB 存储引擎有一个特殊功能叫&quot;自适应哈希索引&quot;，当某个索引值被使用的非常频繁，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</li></ul></li><li><strong>全文索引</strong><ul><li>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</li><li>全文索引一般使用倒排索引实现，它记录者关键词到其所在的文档的映射</li><li>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</li></ul></li><li><strong>空间数据索引</strong><ul><li>MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度进行组合查询。</li></ul></li></ul><h2 id="什么是b-树-为什么b-树成为主要的sql数据库的索引实现" tabindex="-1"><a class="header-anchor" href="#什么是b-树-为什么b-树成为主要的sql数据库的索引实现" aria-hidden="true">#</a> 什么是B+树？为什么B+树成为主要的SQL数据库的索引实现？</h2><ul><li><strong>什么是 B+Tree?</strong></li></ul><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi + 1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于 keyi+1。</p><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/061c88c1-572f-424f-b580-9cbce903a3fe.png" alt="img" loading="lazy"></p><ul><li><strong>为什么是 B+ Tree？</strong><ul><li>为了减少磁盘读取次数，决定了树的高度不能高，所以必须是先 B-Tree；</li><li>以页为单位读取使得一次 I/O 就能完全载入一个节点，且相邻的节点也能够被预先载入；所以数据放在叶子节点，本质上是一个 Page 页；</li><li>为了支持范围查询以及关联关系，页中数据需要有序，且页的尾部节点指向下一个页的头部；</li></ul></li><li><strong>B+ 树索引可以分为聚簇索引和非聚簇索引？</strong></li></ul><ol><li>主索引就是聚簇索引(也称为聚集索引，clustered index)</li><li>辅助索引(有时也称非聚簇索引或二级索引，secondary index，non-clustered index)。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/db-mysql-index-1.png" alt="img" loading="lazy"></p><p>如上图，<strong>主键索引的叶子节点保存的是真正的数据。而辅助索引叶子节点的数据区保存的是主键索引关键字的值</strong></p><p>假设要查询 name == C 的数据，其搜索过程如下：</p><p>​ a)先在辅助索引中通过 C 查询最后找到主键 id = 9；</p><p>​ b)在主键索引中搜索 id 为9的数据，最终在主键索引的叶子节点中获取到真正的数据。所以 通过辅助索引进行检索，需要检索两次索引。</p><p>之所以这样设计，一个原因就是：如果和 MyISAM 一样在主键索引和辅助索引的叶子节点中都存放数据行指针，一旦数据发生迁移，则需要去重新组织维护所有的索引。</p><h2 id="那你知道什么是覆盖索引和回表吗" tabindex="-1"><a class="header-anchor" href="#那你知道什么是覆盖索引和回表吗" aria-hidden="true">#</a> 那你知道什么是覆盖索引和回表吗？</h2><p>覆盖索引指是在一次查询中，如果<strong>一个索引包含或者说覆盖所有需要查询的字段的值</strong>，我们就称之为覆盖索引，而不再需要回表查询。</p><p>而要确定一个查询是否是覆盖索引，我们只需要 explain sql 语句看 Extra 的结果是否是&quot;Using index&quot;即可。</p><p>比如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 查询的name无法从索引数据获取</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> id<span class="token punctuation">,</span>age <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//可以直接从索引获取</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="什么是-mvcc-说说-mysql-实现-mvcc-的原理" tabindex="-1"><a class="header-anchor" href="#什么是-mvcc-说说-mysql-实现-mvcc-的原理" aria-hidden="true">#</a> 什么是 MVCC？ 说说 MySQL 实现 MVCC 的原理？</h2><ul><li><strong>什么是 MVCC？</strong></li></ul><p>MVCC，全称 Multi-Version Concurrency Control，即<code>多版本并发控制</code>。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p>在 Mysql 的 InnoDB 引擎中就是指在<code>已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)</code>这两种隔离级别下的事务对于 SELECT 操作会访问版本链中的记录的过程。</p><p>这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。</p><ul><li><strong>MySQL 的 InnoDB 引擎实现 MVCC 的3个基础点</strong></li></ul><ol><li><strong>隐式字段</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/db-mysql-mvcc-1.png" alt="img" loading="lazy"></p><p>如上图，DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键；DB_TRX_ID 是当前操作该记录的事务 ID；而 DB_ROLE_PTR 是一个回滚指针，用于配合 undo 日志，指向上一个旧指针；delete flag 没有展示出来。</p><ol start="2"><li><strong>undo log</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/db-mysql-mvcc-4.png" alt="img" loading="lazy"></p><p>从上面，我们就可以看出，不同事务或者相同事务的同一记录的修改，会导致该记录的 undo log 成为一条记录版本线性表，即链表，undo log 的链首就是最新的旧记录，链尾就是最早的旧记录</p><ol start="3"><li><strong>ReadView</strong></li></ol><p>已提交读和可重复读的区别就在于它们生成 ReadView 的策略不同。</p><p>ReadView 中主要有两个列表来存储我们系统中当期那活跃着的读写事务，也就是 begin 了还未提交的事务。通过这个列表来判断记录的某个版本是否对当期事务可见。假设当前列表里的事务 id 为[80,100].</p><pre><code>a) 如果你要访问的记录版本的事务 id 为 50，比当前列表最小的 id 80 小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。

b) 如果你要访问的记录版本的事务 id 为 90，发现此事务在列表 id 最大值和最小值之间，那就判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能访问，如果不在那说明事务已经提交，所以此版本可以被访问。
</code></pre><p>​ c) 如果你要访问的记录版本的事务 id 为110，那比事务列表最大 id 100 都大，那说明这个版本是在 ReadView 生成之后才发生的，所以不能被访问。</p><p>这些记录都是去 undo log 链里面找的，先找最近记录，如果最近这一条记录事务 id 不符合条件，不可见的话，再去找上一个版本比较当前事务的 id 和这个版本事务 id 能不能访问，以此类推直到返回可见的版本或者结束。</p><ul><li><strong>举个例子</strong> ，在已提交读隔离级别下</li></ul><p>比如此时有一个事务 id 为100的事务，修改了 name，使得 name 等于小明2，但是事务还没提交，则此时的版本链是</p><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/db-mysql-mvcc-11.jpeg" alt="img" loading="lazy"></p><p>那此时另一个事务发起了 select 语句要查询 id 为1的记录，那此时生成的 ReadView 列表只有[100]。那就去版本链找，首先肯定先找最近的一条，发现 trx_id 是100，也就是 name 为小明2的那条记录，发现在列表内，所以不能访问。</p><p>这时候就通过指针继续找下一条，name 为小明1的记录，发现 trx_id 是60，小于 列表中的最小 id，所以可以访问，访问结果为小明1.</p><p>那这个时候我们把事务 id 为100的事务提交了，并且新建一个事务 id 为110也修改 id 为1的记录，并且不提交事务</p><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/db-mysql-mvcc-12.jpeg" alt="img" loading="lazy"></p><p>这时候版本链就是</p><p><img src="https://cdn.jsdelivr.net/gh/itmarico/image-repository/img/db-mysql-mvcc-13.jpeg" alt="img" loading="lazy"></p><p>这时候之前那个 select 事务又执行了一次查询，要查询 id 为1的记录。</p><p><strong>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的 ReadView，而可重复读隔离级别则在第一次读的时候生成一个 ReadView，之后的读都复用之前的 ReadView</strong>。</p><ol><li><p>如果你是已提交读隔离级别，这时候你会重新生成一个 ReadView，那你的活动事务列表中的值就变了，完成了[110]。按照以上的说法，你去版本链通过 trx_id 对比查找合适的结果就是小明2.</p></li><li><p>如果你是可重复读隔离级别，这时候你的 ReadView 还是第一次 select 时候生成的 ReadView，也就是列表的值还是[100]。所以 select 的结果是小明1。所以第二次 select 结果和第一次一样，所以叫可重复读！</p></li></ol><p>这就是 Mysql 的 MVVC，通过版本链，实现多版本，可并发读-写，写-读。通过 ReadView 生成策略的不同实现不同的隔离级别。</p><h2 id="mysql-锁的类型有哪些呢-🚩" tabindex="-1"><a class="header-anchor" href="#mysql-锁的类型有哪些呢-🚩" aria-hidden="true">#</a> MySQL 锁的类型有哪些呢？🚩</h2><p><strong>说两个维度</strong>：</p><ul><li>共享锁（简称 S 锁）和排他锁（简称 X 锁） <ul><li><strong>读锁</strong>是共享的，可以通过 lock in share mode 实现，这时候只能读不能写。</li><li><strong>写锁</strong>是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁两种。</li></ul></li><li>表锁和行锁 <ul><li><strong>表锁</strong>会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如 alter 修改表结构的时候去锁表。</li><li><strong>行锁</strong>又可以分为乐观锁和悲观锁 <ul><li>悲观锁可以通过 for update 实现</li><li>乐观锁可以通过版本号实现</li></ul></li></ul></li></ul><p><strong>两个维度结合来看：</strong></p><ul><li>共享锁(行锁)：Shared Locks <ul><li>读锁（s 锁），多个事务对于同一个数据可以共享访问，不能操作修改</li><li>使用方法 ： <ul><li>加锁：select * FROM table WHERE id = 1 LOCK IN SHARE MODE</li><li>释放：COMMIT/ROLLBACK</li></ul></li></ul></li><li>排他锁（行锁）：Exclulsive Locks <ul><li>写锁（X 锁），互斥锁/独占锁，事务获取一个数据 X 锁，其他事务就不能获取该行的读锁和写锁（s锁、X 锁），只有获取了该排他锁的事务是可以对数据行进行读取和修改</li><li>使用方法： <ul><li>DELETE/UPDATE/INSERT --加锁</li><li>SELECT * FROM table WHERE ... FOR UPDATE --加锁</li><li>COMMIT/ROLLBACK --释放锁</li></ul></li></ul></li><li>意向共享锁（IS） <ul><li>一个数据行加共享锁前必须先取得该表的 IS 锁，意向共享锁之间是可以相互兼容的；意向排他锁（IX）一个数据加排他锁前必须先取得该表的 IX 锁，意向排他锁之间是可以互相兼容的；意向锁（IS、IX）是 InnoDB 引擎操作数据之前自动加的，不需要用户干预；意义：当事务操作需要锁表时，只需判断意向锁是会否存在，存在时则可快速返回表不能启用表锁</li><li>意向共享锁（IS 锁）（表锁）：Intention Shared Locks <ul><li>表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的 IS 锁。</li></ul></li><li>意向排他锁（IX 锁）（表锁）：Intention Exclusive Locks <ul><li>表示事务准备给数据加入排它锁，说明事务在一个数据行加排在他锁前必须先获取该表的 IX 锁。</li></ul></li></ul></li></ul><h2 id="你们数据量级多大-分库分表怎么做的-🚀" tabindex="-1"><a class="header-anchor" href="#你们数据量级多大-分库分表怎么做的-🚀" aria-hidden="true">#</a> 你们数据量级多大？分库分表怎么做的？🚀</h2><p>首先分库分表分为垂直和水平两个方式，一般来说我们拆分的顺序是先垂直后水平。</p><ul><li><p><strong>垂直分库</strong></p></li><li><p><strong>垂直分表</strong></p></li></ul>`,157),o=[e];function p(t,r){return s(),n("div",null,o)}const u=l(a,[["render",p],["__file","mysql.html.vue"]]);export{u as default};
