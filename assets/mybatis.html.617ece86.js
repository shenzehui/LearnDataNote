import{_ as s}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as n,d as t}from"./app.593732e6.js";const e={},p=t(`<h2 id="mybatis-中存在哪些优点和缺点" tabindex="-1"><a class="header-anchor" href="#mybatis-中存在哪些优点和缺点" aria-hidden="true">#</a> MyBatis 中存在哪些优点和缺点</h2><p>优点：</p><ol><li>基于 SQL 语句编程，相对灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 单独写，解除 sql 与程序代码的耦合，便于统一管理。</li><li>与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</li><li>很好的与各种数据库兼容（因为 MyBatis 使用了 JDBC 来连接数据库，所以只要 JDBC 支持数据库 MyBatis 都支持）。</li><li>能够与 Spring 很好的集成；</li><li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li></ol><p>缺点：</p><ol><li>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有第一要求。</li><li>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li></ol><h2 id="简述-mybatis-的插件运行原理-如何编写一个插件" tabindex="-1"><a class="header-anchor" href="#简述-mybatis-的插件运行原理-如何编写一个插件" aria-hidden="true">#</a> 简述 Mybatis 的插件运行原理，如何编写一个插件？</h2><p>答：Mybatis 只支持针对 ParameterHander（sql 中所需的参数数据类型转化）、ResultSetHandler（结果集）、StatementHandler（负责设置参数，结果集转换）、Executor（负责生成 sql 语句） 这 4 种接口的插件，Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以及实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvacationHandler 的 invoke() 方法，拦截那些你指定需要拦截的方法。</p><ul><li>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</li><li>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；</li><li>ParameterHandler：拦截参数的处理；</li><li>ResultSetHandler：拦截结果集的处理。</li></ul><p>编写插件：实现 MyBatis 的 Interceptor 接口并复写 interceptor() 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法，在配置文件中配置编写的插件。</p><p><strong>自定义插件实现示例：</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Intercepts</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Signature</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">Executor</span><span class="token punctuation">.</span> <span class="token keyword">class</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token string">&quot;query&quot;</span><span class="token punctuation">,</span>
                        args <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">MappedStatement</span><span class="token punctuation">.</span> <span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span> <span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">RowBounds</span><span class="token punctuation">.</span> <span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">ResultHandler</span><span class="token punctuation">.</span> <span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Invocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>

        <span class="token class-name">Object</span> target <span class="token operator">=</span> invocation<span class="token punctuation">.</span> <span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//被代理对象</span>

        <span class="token class-name">Method</span> method <span class="token operator">=</span> invocation<span class="token punctuation">.</span> <span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//代理方法</span>

        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> invocation<span class="token punctuation">.</span> <span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//方法参数</span>

        <span class="token comment">// do something . . . . . .  方法拦截前执行代码块</span>

        <span class="token class-name">Object</span> result <span class="token operator">=</span> invocation<span class="token punctuation">.</span> <span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// do something . . . . . . . 方法拦截后执行代码块</span>

        <span class="token keyword">return</span> result<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#和-的区别是什么" aria-hidden="true">#</a> #{} 和 \${} 的区别是什么？</h2><p>#{} 是预编译处理，是占位符，\${} 是字符串替换，是拼接符。</p><p>Mybatis 在处理 #{} 时，会将 sql 中的 #{} 替换为 ？号，调用 PreparedStatement 来赋值；</p><p>Mybatis 在处理 \${} 时，就是把 \${} 替换成变量的值，调用 Statement 来赋值；</p><p>#{} 的变量替换是在 DBMS 中、变量替换后，#{} 对应的变量自动加上单引号；</p><p>\${} 的变量替换是在 DBMS 外、变量替换后，\${} 对应的变量不会加上单引号；</p><p><strong>使用 #{} 可以有效的防止 SQL 注入，提高系统安全性。</strong></p><h2 id="👊-基础" tabindex="-1"><a class="header-anchor" href="#👊-基础" aria-hidden="true">#</a> 👊 基础</h2><h3 id="说一说什么是-mybatis" tabindex="-1"><a class="header-anchor" href="#说一说什么是-mybatis" aria-hidden="true">#</a> 说一说什么是 MyBatis?</h3><p>先吹一下：</p><ul><li>Mybatis 是一个半 ORM(对象关系映射)框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。</li><li>MyBatis 可以使用 XML 或注解配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li></ul><p>再说一下缺点：</p><ul><li>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功能有一定的要求。</li><li>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li></ul><blockquote><p>ORM 是什么？</p></blockquote><p><img src="https://s1.vika.cn/space/2022/12/02/bd0df350c9834de191d179d5d9456354" alt="image-20221202184508372" loading="lazy"></p><ul><li>ORM(Object Relational Mapping)，对象关系映射，是一种为了解决关系型数据库数据与简单 Java 对象(POJO)的映射关系技术。简单来说，ORM 是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</li></ul><blockquote><p>为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</p></blockquote><ul><li>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</li><li>而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成，所以，被称之为半自动 ORM 映射工具。</li></ul><blockquote><p>JDBC 编程有哪些不足之处，MyBatis 是如何解决的？</p></blockquote><p><img src="https://s1.vika.cn/space/2022/12/02/caa025cb3bae4678a94f2c223ec46f84" alt="" loading="lazy"></p><ul><li>1数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能，在 mybatis-config.xml 中配置数据库连接池，使用连接池统一管理数据库连接。</li><li>2.sql 语句写在代码中造成代码不易维护，将 sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。</li><li>3.向 sql 语句传参麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数一一对应。Mybatis 自动将 java 对象映射至 sql 语句。</li><li>4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。Mybatis 自动将 sql 执行结果映射至 java 对象。</li></ul><h3 id="hibernate-和-mybatis-有什么区别" tabindex="-1"><a class="header-anchor" href="#hibernate-和-mybatis-有什么区别" aria-hidden="true">#</a> Hibernate 和 MyBatis 有什么区别？</h3><p><strong>相同点</strong></p><ul><li>都是对 jdbc 的封装，都是应用于持久层的框架 。</li></ul><p><strong>不同点</strong></p><p><strong>1、映射关系</strong></p><ul><li>MyBatis 是一个半自动映射的框架，配置 Java 对象与 sql 语句执行结果的对应关系，多表关联关系配置简单。</li><li>Hibernate 是一个全表映射的框架，配置 Java 对象与数据库表的对应 关系，多表关联关系配置复杂。</li></ul><p><strong>2、SQL 优化和移植性</strong></p><ul><li>Hibernate 对 SQL 语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL(Hibernate Query Language)操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但 SQL 语句优化困难。</li><li>MyBatis 需要手动编写 SQL，支持动态 SQL，处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用 SQL 语句操作数据库，不支持数据库无关性，但 sql 语句优化容易。</li></ul><p><strong>3、MyBatis 和 Hibernate 的适用场景不同</strong></p><ul><li>Hibernate 是标准的 ORM 框架，SQL 编写量较少，但不够灵活，适合需求相对稳定，中小型的软件项目，比如：办公自动化系统</li><li>MyBatis 是半 ORM 框架，需要编写较多 SQL，但是比较灵活，适合于需求变化频繁，快速迭代的项目，比如：电商网站</li></ul><h3 id="mybatis-使用过程-生命周期" tabindex="-1"><a class="header-anchor" href="#mybatis-使用过程-生命周期" aria-hidden="true">#</a> MyBatis 使用过程？生命周期？</h3><p>MyBatis 基本使用的过程大概可以分为这么几步：</p><p><img src="https://s1.vika.cn/space/2022/12/02/ec195b8f0ce742da9eb5fc8d9f54838d" alt="image-20221202194409318" loading="lazy"></p><ul><li><strong>1.创建 SqlSessionFactory</strong></li></ul><p>可以从配置或者直接编码来创建 SqlSessionFactory</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> resource <span class="token operator">=</span> <span class="token string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> <span class="token class-name">Resources</span><span class="token punctuation">.</span> getResourceAsStream <span class="token punctuation">(</span>resource<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token class-name">SqlSessionFactory</span> sqlSessionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>2.通过 SqlSessionFactory 创建 SqlSession</strong></li></ul><p>SqlSession(会话) 可以理解为程序和数据库之间的桥梁</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">SqlSession</span> session <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><strong>3.通过 sqlsession 执行数据库操作</strong></li></ul><p>可以通过 SqlSession 实例来直接执行已映射的 SQL 语句：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Blog</span> blog <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Blog</span><span class="token punctuation">)</span>session<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span><span class="token punctuation">,</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>更常用的方式是先获取 Mapper(映射)，然后再执行 SQL 语句：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">BlogMapper</span> mapper <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">BlogMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Blog</span> blog <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">selectBlog</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>4.调用 session.commit() 提交事务</strong></li></ul><p>如果是更新、删除语句，我们还需提交一下事务。</p><ul><li><strong>5.调用 session.close() 关闭会话</strong></li></ul><p>最后一定要关闭会话</p><blockquote><p>MyBatis 生命周期？</p></blockquote><p>上面提到了几个 MyBatis 的组件，一般说的 MyBatis 生命周期就是这些组件的什么周期。</p><ul><li>SqlSessionFactoryBuilder</li></ul><p>一旦创建了 SqlSessoinFactory，就不需要它了。因此 SqlSessionFactoryBuilder 实例的生命周期只存在于方法的内部。</p><ul><li>SqlSessionFactory</li></ul><p>SqlSessionFactory 是用来创建 SqlSession 的，相当于一个数据库连接池，每次创建 SqlSessionFactory 都会使用数据库资源，多次创建和销毁是对资源的浪费。所以 SqlSessionFactory 是应用级的生命周期，而且应该是单例的。</p><ul><li>SqlSession</li></ul><p>SqlSession 相当于 JDBC 中的 Connection，SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳生命周期是一次请求或一个方法。</p><ul><li>Mapper</li></ul><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的，它的生命周期在 sqlsession 事务方法之内，一般控制在方法级。</p><p><img src="https://s1.vika.cn/space/2022/12/02/584b070a9cc843558b8de31d7f732b14" alt="image-20221202195837737" loading="lazy"></p><p>当然，万物皆可集成 Spring，MyBatis 通常也是和 Spring 集成使用，Spring 可以帮助我们创建线程安全的、基于事务的 SqlSession 和映射器，并将它们注入到我们的 bean 中，我们不需要关心它们的创建过程和生命周期，那就是另外的故事了。</p><h3 id="在-mapper-中如何传递多个参数" tabindex="-1"><a class="header-anchor" href="#在-mapper-中如何传递多个参数" aria-hidden="true">#</a> 在 Mapper 中如何传递多个参数？</h3><p><img src="https://s1.vika.cn/space/2022/12/02/3f36aa2c375d48ee80b2aea72391b001" alt="image-20221202200726706" loading="lazy"></p><p><strong>方法1：顺序传参法</strong></p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>public User selectUser(String name,int deptId);
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>selectUser<span class="token punctuation">&quot;</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UserResultMap<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    select * from user
    where user_name=#{0} and dept_id=#{1}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span> <span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>#{}</strong> 里面的数字代表传入参数的顺序。</li><li>这种方式不建议使用，sql 层表达不直观， 且一旦顺序调整容易出错。</li></ul><p><strong>方法2：@Param 注解传参法</strong></p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>public User selectUser(@Param(&quot;userName&quot;) String name,@Param(&quot;deptId&quot;) int deptId);
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>selectUser<span class="token punctuation">&quot;</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UserResultMap<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    select * from user
    where user_name=#{userName} and dept_id=#{deptId}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>#{}</strong> 里面的名称对应的是注解 @Param 括号里面修饰的名称。</li><li>这种方法在参数不多的情况下还是比较直观的。（推荐使用）。</li></ul><p><strong>方法3：Map 传参法</strong></p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>public User selectUser(Map <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>String,Object</span><span class="token punctuation">&gt;</span></span> params);
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>selectUser<span class="token punctuation">&quot;</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>java.util.Map<span class="token punctuation">&quot;</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UserResultMap<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
     select * from user
     where user_name=#{userName} and dept_id=#{deptId}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="公众号" tabindex="-1"><a class="header-anchor" href="#公众号" aria-hidden="true">#</a> 公众号</h2><p><img src="https://s1.vika.cn/space/2022/12/01/f1f467dd3b8e4984a50dce782aa346ff" alt="" loading="lazy"></p>`,84),l=[p];function o(i,c){return a(),n("div",null,l)}const d=s(e,[["render",o],["__file","mybatis.html.vue"]]);export{d as default};
